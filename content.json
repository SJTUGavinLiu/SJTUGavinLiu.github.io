{"pages":[],"posts":[{"title":"GET&POST&AJAX","text":"最近整了点web相关的工作，借此整理了一下HTTP请求相关的内容。 HTTP (Hyper Text Transfer Protocol)HTTP-超文本传输协议工作于Server-Client架构上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 而GET和POST则是HTTP最常用的两个方法。 GET &amp; POST先搬运一段维基百科上的定义 GETGET requests a representation of the specified resource. Note that GET should NOT be used for operations that cause side-effects, such as using it for taking actions in web applications. One reason for this is that GET may be used arbitrarily by robots or crawlers, which should not need to consider the side effects that a request should cause. POSTPOST submits data to be processed (e.g., from an HTML form) to the identified resource. The data is included in the body of the request. This may result in the creation of a new resource or the updates of existing resources or both. 由此可以看出，GET代表一个幂等（Idempotent）的读取操作，而POST则代表一个不幂等的更新操作。 所谓幂等，即任意多次执行所产生的影响均与依次执行的影响相同。 JQuery AJAX get() &amp; post()AJAX - Asynchronous Javascript And XML 无需重新加载整个网页更新部分网页的技术 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* get */$.get(URL,callback); /* example */$.get('http://127.0.0.1:5000/data',function(data,status){ console.log(data);});/* post */$.post(URL,data,callback)/* example */$.post('http://127.0.0.1:5000/data',{ name: 'gavin'},function(data,status){ console.log(data);});/* ajax template example */$.ajax({ type: 'get', url: 'http://127.0.0.1:5000/demo/data', dataType: \"jsonp\", // request format: jsonp success: function (res) { console.log(res); }, error: function (msg) { console.log(msg); }}); $.ajax({ type: 'post', url: 'http://127.0.0.1:5000/demo/data', data: JSON.stringify({'trans': trans, \"core\": core, \"year\": year, \"month\": month}), dataType: \"jsonp\", contentType: \"application/json; charset=utf-8\", success: function (res) { console.log(res); }, error: function (msg) { console.log(msg); }});","link":"/2020/01/28/GET&POST&AJAX/"},{"title":"leetcode126","text":"单词接龙Ⅱ给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。说明: 如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 题目的思路是比较明晰的，先通过BFS找到最短路径，再backtrack出所有路径即可。 思路一 BFS的过程中记录下每层的单词，这样利用这个信息进行回溯。这个思路在碰到长WordList就行不通了，原因在于每层的单词数量过多，导致回溯的开销爆炸-.- 思路二 存储每层的单词显然行不通了，于是就想到了通过在BFS的过程中建立一个记录层次间连接的邻接表（Adjacent List）来加速回溯的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution {private: int wordLen; string end;public: bool isAjac(string a, string b) { // 0: not ajacent or same // 1: ajacent bool flag = 0; for(int i = 0; i &lt; wordLen; i++) { if(flag &amp;&amp; a[i] != b[i]) return 0; if(a[i] != b[i]) flag = 1; } return flag; } void backtrack(string cur, vector&lt;vector&lt;string&gt;&gt; &amp;res, vector&lt;string&gt; &amp;tmp, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; nextStep) { if(isAjac(cur,end)) { tmp.push_back(end); res.push_back(tmp); tmp.pop_back(); } else { for(auto word: nextStep[cur]) { tmp.push_back(word); backtrack(word, res, tmp, nextStep); tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; s(wordList.begin(), wordList.end()); if(!s.count(endWord)) return res; wordLen = beginWord.size(); end = endWord; unordered_set&lt;string&gt; p{beginWord}; unordered_set&lt;string&gt; q; unordered_map&lt;string, vector&lt;string&gt;&gt; nextStep; // To store words that can be reached from the given word. bool flag = 0; // when the path has been found, flag = 1 while(!p.empty() &amp;&amp; !flag) { for(auto iter1 = p.begin(); iter1 != p.end(); iter1++) { for(auto iter2 = s.begin(); iter2 != s.end(); iter2++) { if(isAjac(*iter1, *iter2)) { if(*iter2 == endWord) flag = 1; nextStep[*iter1].push_back(*iter2); q.insert(*iter2); } } } for(auto iter = q.begin(); iter != q.end(); iter++) { s.erase(*iter); } swap(p,q); q.clear(); } vector&lt;string&gt; tmp(1, beginWord); if(flag) { backtrack(beginWord, res, tmp, nextStep); } return res; }}; 思路三 可以通过双向BFS进一步提升算法效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222class Solution {private: int wordLen; string end;public: bool isAjac(string a, string b) { // 0: not ajacent or same // 1: ajacent bool flag = 0; for(int i = 0; i &lt; wordLen; i++) { if(flag &amp;&amp; a[i] != b[i]) return 0; if(a[i] != b[i]) flag = 1; } return flag; } void backtrack(string&amp; cur, vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; tmp, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; nextStep) { if(isAjac(cur,end)) { tmp.push_back(end); res.push_back(tmp); tmp.pop_back(); } else { for(auto word: nextStep[cur]) { tmp.push_back(word); backtrack(word, res, tmp, nextStep); tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; s(wordList.begin(), wordList.end()); if(!s.count(endWord)) return res; wordLen = beginWord.size(); end = endWord; unordered_set&lt;string&gt; p{beginWord}; unordered_set&lt;string&gt; q; unordered_map&lt;string, vector&lt;string&gt;&gt; nextStep; // To store words that can be reached from the given word. bool flag = 0; // when the path has been found, flag = 1 while(!p.empty() &amp;&amp; !flag) { for(auto iter = p.begin(); iter != p.end(); iter++) { string str = *iter; for(int i = 0; i &lt; wordLen; i++) { char c = str[i]; for(char j = 'a'; j &lt;= 'z'; j++) { str[i] = j; if(str == endWord) flag = 1; if(s.count(str)) { nextStep[*iter].push_back(str); q.insert(str); } } str[i] = c; } } for(auto iter = q.begin(); iter != q.end(); iter++) { s.erase(*iter); } swap(p,q); q.clear(); } if(flag) { vector&lt;string&gt; tmp(1, beginWord); backtrack(beginWord, res, tmp, nextStep); } return res; }};/* Solution 3 Bidirectional BFS*/static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {private: int wordLen; string end;public: bool isAjac(string&amp; a, string&amp; b) { // 0: not ajacent or same // 1: ajacent bool flag = 0; for(int i = 0; i &lt; wordLen; i++) { if(flag &amp;&amp; a[i] != b[i]) return 0; if(a[i] != b[i]) flag = 1; } return flag; } void backtrack(string&amp; cur, vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; tmp, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; nextStep) { if(isAjac(cur,end)) { tmp.push_back(end); res.push_back(tmp); tmp.pop_back(); } else { for(auto&amp; word: nextStep[cur]) { tmp.push_back(word); backtrack(word, res, tmp, nextStep); tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; s(wordList.begin(), wordList.end()); if(!s.count(endWord)) return res; wordLen = beginWord.size(); end = endWord; unordered_set&lt;string&gt; p1{beginWord}; unordered_set&lt;string&gt; p2{endWord}; unordered_set&lt;string&gt; q; unordered_map&lt;string, vector&lt;string&gt;&gt; nextStep; // To store words that can be reached from the given word. bool flag = 0; // when the path has been found, flag = 1 bool back = 0; // when the direction of BFS is backward, back = 1 s.erase(endWord); while(!p1.empty() &amp;&amp; !p2.empty() &amp;&amp; !flag) { if(p1.size() &gt; p2.size()) { swap(p1,p2); back = !back; } for (const string&amp; w : p1) s.erase(w); for (const string&amp; w : p2) s.erase(w); for(auto iter = p1.begin(); iter != p1.end(); iter++) { string str = *iter; for(int i = 0; i &lt; wordLen; i++) { char c = str[i]; for(char j = 'a'; j &lt;= 'z'; j++) { str[i] = j; if(p2.count(str)) { flag = 1; if(back) nextStep[str].push_back(*iter); else nextStep[*iter].push_back(str); } if(s.count(str)) { if(back) nextStep[str].push_back(*iter); else nextStep[*iter].push_back(str); q.insert(str); } } str[i] = c; } } swap(p1,q); q.clear(); } if(flag) { vector&lt;string&gt; tmp(1, beginWord); backtrack(beginWord, res, tmp, nextStep); } return res; }};","link":"/2020/01/29/leetcode126/"},{"title":"同时在Github与Coding上部署Hexo","text":"配置SSH公钥我们可以通过SSH公钥来访问仓库，生成公钥的操作如下（配置的过程默认即可） 1ssh-keygen -t rsa -C &lt;your_email@example.com&gt; 将生成的id_rsa.pub内容添加到Coding与Github的SSH公钥即可。 之后我们就可以直接对仓库进行操作，而不需要输入用户名和密码了，例如 12git@git.coding.net:Gavin_liudu/Gavin_liudu.coding.me.gitgit@github.com:SJTUGavinLiu/SJTUGavinLiu.github.io.git 之后在blog根目录下的_config.yml中如下设置即可 12345deploy: type: git repo: github: https://github.com/SJTUGavinLiu/SJTUGavinLiu.github.io.git,master coding: git@git.coding.net:Gavin_liudu/Gavin_liudu.coding.me.git,master 个人域名绑定在阿里云的域名列表中加入记录 主机记录www，记录类型A，记录值是IP地址， 设置主机记录@，记录类型CNAME，记录值是Page页面地址 文本内的图片插入一开始有考虑用图床来实现图片的中转，但是有两个问题还是让我放弃这一个想法 图床存在挂掉的可能性（图床挂了，页面里的图片就全崩了，恢复极其麻烦） 由于我平时习惯用typora来写一些内容，所以图片都默认使用相对路径的形式在文本中进行标识。图床多出了上传图片并修改文本中图片地址的过程，实在麻烦 因此我还是选择了把图片存在了source/images/的路径下，通过相对路径的形式调取。 GIT LFS的引入Git在存储二进制文件，例如音频，图像，视频等的时候效率不高，因为Git默认会压缩并存储二进制文件的所有完整版本。由于我选择将图片存入仓库中，随着博文数量的增加，Git仓库文件会不断地增长，最终超出容量的上界。 针对这个问题，Git-LFS提供了一个合理的解决方案，即只在真正的Git仓库中保存二进制文件的哈希等数据，而将真实的文件存储在GIT-LFS的服务器上。 Git LFS的处理方式类似于.gitignore 12git lfs installgit lfs track \"*.png\" 一切似乎都非常美好，然而悲伤的是，我的博客是基于Github/Coding Page的，所以图片必须上传到repo里，否则似乎无法显示QAQ，因此Git-LFS的方案只能暂时弃置。 Typora与Hexo的对接整了一个小脚本，可以把Typora中写好的东西打上分类，标签导入_post文件夹里（包括图片）详见Typora2hexo.py","link":"/2020/01/18/同时在Github与Coding上部署Hexo/"},{"title":"博客开张","text":"「Gavin的碎碎念~」开张^^关于为什么开这个博客平时也会用Typora写一些东西，写的多了，查阅起来就不是很方便了。因此我就想到利用Hexo+Github Page建立一个静态博客，一方面省去了服务器的开支，另一方面可以利用现成的模板设计去实现类似于查找，归类，时间线的功能，省去了自己重复开发的时间。没有的功能自己魔改也并不麻烦。于是乎，「Gavin的碎碎念~」就诞生了：） 博客里会有些啥嘞所谓碎碎念，就是啥都会谈一些。内容不局限于以下 技术文档（最近在刷leetcode可能也会写一些例题相关ORZ） 生活分享与一些小随笔 游戏的体验评测（八方旅人ing，或许也会有音乐，电影，书籍这些，根本就很少看书了好伐） 练琴（Guitar &amp; Keyboard）的心得体会以及一些基础乐理的笔记 flag Finally从「Gavin的碎碎念~」开始，养成做完事后复盘的好习惯，接受一切监督QAQ。绝不咕咕咕。","link":"/2020/01/17/博客开张/"}],"tags":[{"name":"web","slug":"web","link":"/tags/web/"},{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"get","slug":"get","link":"/tags/get/"},{"name":"post","slug":"post","link":"/tags/post/"},{"name":"backtrack","slug":"backtrack","link":"/tags/backtrack/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"path","slug":"path","link":"/tags/path/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"域名","slug":"域名","link":"/tags/域名/"}],"categories":[{"name":"文档","slug":"文档","link":"/categories/文档/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"web","slug":"文档/web","link":"/categories/文档/web/"},{"name":"leetcode","slug":"文档/leetcode","link":"/categories/文档/leetcode/"},{"name":"博客搭建","slug":"文档/博客搭建","link":"/categories/文档/博客搭建/"}]}