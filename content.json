{"pages":[],"posts":[{"title":"GET&POST&AJAX","text":"最近整了点web相关的工作，借此整理了一下HTTP请求相关的内容。 HTTP (Hyper Text Transfer Protocol)HTTP-超文本传输协议工作于Server-Client架构上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 而GET和POST则是HTTP最常用的两个方法。 GET &amp; POST先搬运一段维基百科上的定义 GETGET requests a representation of the specified resource. Note that GET should NOT be used for operations that cause side-effects, such as using it for taking actions in web applications. One reason for this is that GET may be used arbitrarily by robots or crawlers, which should not need to consider the side effects that a request should cause. POSTPOST submits data to be processed (e.g., from an HTML form) to the identified resource. The data is included in the body of the request. This may result in the creation of a new resource or the updates of existing resources or both. 由此可以看出，GET代表一个幂等（Idempotent）的读取操作，而POST则代表一个不幂等的更新操作。 所谓幂等，即任意多次执行所产生的影响均与依次执行的影响相同。 JQuery AJAX get() &amp; post()AJAX - Asynchronous Javascript And XML 无需重新加载整个网页更新部分网页的技术 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* get */$.get(URL,callback); /* example */$.get('http://127.0.0.1:5000/data',function(data,status){ console.log(data);});/* post */$.post(URL,data,callback)/* example */$.post('http://127.0.0.1:5000/data',{ name: 'gavin'},function(data,status){ console.log(data);});/* ajax template example */$.ajax({ type: 'get', url: 'http://127.0.0.1:5000/demo/data', dataType: \"jsonp\", // request format: jsonp success: function (res) { console.log(res); }, error: function (msg) { console.log(msg); }}); $.ajax({ type: 'post', url: 'http://127.0.0.1:5000/demo/data', data: JSON.stringify({'trans': trans, \"core\": core, \"year\": year, \"month\": month}), dataType: \"jsonp\", contentType: \"application/json; charset=utf-8\", success: function (res) { console.log(res); }, error: function (msg) { console.log(msg); }});","link":"/2020/01/28/GET&POST&AJAX/"},{"title":"leetcode128","text":"最长连续序列给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 最直接的想法是排序加遍历，但是不符合时间复杂度线性的要求。 思路 直观上，我们希望在一遍扫描数组的过程中，对每一个数做如下操作 和已有的序列结合形成新序列 自己独立生成一个序列 为了实现这一想法，我用HashMap来存储每一个数所处序列的长度。对于遍历到的每一个数，我们都根据其左右两个数的序列长度来计算总长度，并对两个端点进行更新。我们可以注意到，此时除了端点，序列内其他点在HashMap中的长度并不是其所处序列的长度。这一点是可以接受的，因为我们每次考虑的都是新加入HashMap的数，不可能存在落入已有序列的可能性。 12345678910111213141516171819202122232425262728class Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return 0; unordered_map&lt;int, int&gt; dict; int left, right, curLen; int maxLen = 1; for(auto&amp; num: nums) { if(!dict.count(num)) { left = dict.count(num-1) ? dict[num-1] : 0; right = dict.count(num+1) ? dict[num+1] : 0; curLen = left + right + 1; maxLen = maxLen &gt; curLen ? maxLen : curLen; dict[num] = curLen; // take the place dict[num - left] = curLen; dict[num + right] = curLen; } } return maxLen; }};","link":"/2020/01/29/leetcode128/"},{"title":"leetcode126","text":"单词接龙Ⅱ给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。说明: 如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 题目的思路是比较明晰的，先通过BFS找到最短路径，再backtrack出所有路径即可。 思路一 BFS的过程中记录下每层的单词，这样利用这个信息进行回溯。这个思路在碰到长WordList就行不通了，原因在于每层的单词数量过多，导致回溯的开销爆炸-.- 思路二 存储每层的单词显然行不通了，于是就想到了通过在BFS的过程中建立一个记录层次间连接的邻接表（Adjacent List）来加速回溯的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution {private: int wordLen; string end;public: bool isAjac(string a, string b) { // 0: not ajacent or same // 1: ajacent bool flag = 0; for(int i = 0; i &lt; wordLen; i++) { if(flag &amp;&amp; a[i] != b[i]) return 0; if(a[i] != b[i]) flag = 1; } return flag; } void backtrack(string cur, vector&lt;vector&lt;string&gt;&gt; &amp;res, vector&lt;string&gt; &amp;tmp, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; nextStep) { if(isAjac(cur,end)) { tmp.push_back(end); res.push_back(tmp); tmp.pop_back(); } else { for(auto word: nextStep[cur]) { tmp.push_back(word); backtrack(word, res, tmp, nextStep); tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; s(wordList.begin(), wordList.end()); if(!s.count(endWord)) return res; wordLen = beginWord.size(); end = endWord; unordered_set&lt;string&gt; p{beginWord}; unordered_set&lt;string&gt; q; unordered_map&lt;string, vector&lt;string&gt;&gt; nextStep; // To store words that can be reached from the given word. bool flag = 0; // when the path has been found, flag = 1 while(!p.empty() &amp;&amp; !flag) { for(auto iter1 = p.begin(); iter1 != p.end(); iter1++) { for(auto iter2 = s.begin(); iter2 != s.end(); iter2++) { if(isAjac(*iter1, *iter2)) { if(*iter2 == endWord) flag = 1; nextStep[*iter1].push_back(*iter2); q.insert(*iter2); } } } for(auto iter = q.begin(); iter != q.end(); iter++) { s.erase(*iter); } swap(p,q); q.clear(); } vector&lt;string&gt; tmp(1, beginWord); if(flag) { backtrack(beginWord, res, tmp, nextStep); } return res; }}; 思路三 可以通过双向BFS进一步提升算法效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222class Solution {private: int wordLen; string end;public: bool isAjac(string a, string b) { // 0: not ajacent or same // 1: ajacent bool flag = 0; for(int i = 0; i &lt; wordLen; i++) { if(flag &amp;&amp; a[i] != b[i]) return 0; if(a[i] != b[i]) flag = 1; } return flag; } void backtrack(string&amp; cur, vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; tmp, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; nextStep) { if(isAjac(cur,end)) { tmp.push_back(end); res.push_back(tmp); tmp.pop_back(); } else { for(auto word: nextStep[cur]) { tmp.push_back(word); backtrack(word, res, tmp, nextStep); tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; s(wordList.begin(), wordList.end()); if(!s.count(endWord)) return res; wordLen = beginWord.size(); end = endWord; unordered_set&lt;string&gt; p{beginWord}; unordered_set&lt;string&gt; q; unordered_map&lt;string, vector&lt;string&gt;&gt; nextStep; // To store words that can be reached from the given word. bool flag = 0; // when the path has been found, flag = 1 while(!p.empty() &amp;&amp; !flag) { for(auto iter = p.begin(); iter != p.end(); iter++) { string str = *iter; for(int i = 0; i &lt; wordLen; i++) { char c = str[i]; for(char j = 'a'; j &lt;= 'z'; j++) { str[i] = j; if(str == endWord) flag = 1; if(s.count(str)) { nextStep[*iter].push_back(str); q.insert(str); } } str[i] = c; } } for(auto iter = q.begin(); iter != q.end(); iter++) { s.erase(*iter); } swap(p,q); q.clear(); } if(flag) { vector&lt;string&gt; tmp(1, beginWord); backtrack(beginWord, res, tmp, nextStep); } return res; }};/* Solution 3 Bidirectional BFS*/static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {private: int wordLen; string end;public: bool isAjac(string&amp; a, string&amp; b) { // 0: not ajacent or same // 1: ajacent bool flag = 0; for(int i = 0; i &lt; wordLen; i++) { if(flag &amp;&amp; a[i] != b[i]) return 0; if(a[i] != b[i]) flag = 1; } return flag; } void backtrack(string&amp; cur, vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; tmp, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; nextStep) { if(isAjac(cur,end)) { tmp.push_back(end); res.push_back(tmp); tmp.pop_back(); } else { for(auto&amp; word: nextStep[cur]) { tmp.push_back(word); backtrack(word, res, tmp, nextStep); tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; s(wordList.begin(), wordList.end()); if(!s.count(endWord)) return res; wordLen = beginWord.size(); end = endWord; unordered_set&lt;string&gt; p1{beginWord}; unordered_set&lt;string&gt; p2{endWord}; unordered_set&lt;string&gt; q; unordered_map&lt;string, vector&lt;string&gt;&gt; nextStep; // To store words that can be reached from the given word. bool flag = 0; // when the path has been found, flag = 1 bool back = 0; // when the direction of BFS is backward, back = 1 s.erase(endWord); while(!p1.empty() &amp;&amp; !p2.empty() &amp;&amp; !flag) { if(p1.size() &gt; p2.size()) { swap(p1,p2); back = !back; } for (const string&amp; w : p1) s.erase(w); for (const string&amp; w : p2) s.erase(w); for(auto iter = p1.begin(); iter != p1.end(); iter++) { string str = *iter; for(int i = 0; i &lt; wordLen; i++) { char c = str[i]; for(char j = 'a'; j &lt;= 'z'; j++) { str[i] = j; if(p2.count(str)) { flag = 1; if(back) nextStep[str].push_back(*iter); else nextStep[*iter].push_back(str); } if(s.count(str)) { if(back) nextStep[str].push_back(*iter); else nextStep[*iter].push_back(str); q.insert(str); } } str[i] = c; } } swap(p1,q); q.clear(); } if(flag) { vector&lt;string&gt; tmp(1, beginWord); backtrack(beginWord, res, tmp, nextStep); } return res; }};","link":"/2020/01/29/leetcode126/"},{"title":"leetcode132","text":"分割回文串Ⅱ给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回符合要求的最少分割次数。 思路一 设置动态规划数组dp,dp[i]代表s[:i-1]的minCut。这个做法确实太暴力了，回文串的判定过程中产生了大量冗余计算，例如在判定“abcba”的过程中，事实上我们也知道了“bcb”是回文串。但在这个算法中这些信息并没有得到利用。 12345678910111213141516171819202122232425262728293031class Solution {public: bool isPalin(string s) { int left = 0; int right = s.size() - 1; while(left &lt; right) { if(s[left] != s[right]) return false; left++; right--; } return true; } int minCut(string s) { if(s.empty()) return 0; int len = s.size(); vector&lt;int&gt; dp(len+1,INT_MAX); dp[0] = -1; for(int j = 0; j &lt; len; j++) { for(int i = j; i &gt;= 0; i--) { if(isPalin(s.substr(i,j-i+1))) dp[j+1] = min(dp[j+1],1+dp[i]); } } return dp[len]; }}; 思路二 一个简单的思路的方法是通过$O(n^2)$中心扩散算法先计算出所有字串中的回文串以此简化计算量。 12345678910111213141516171819202122232425262728293031323334353637class Solution {private: int len;public: void SearchPalin(string&amp;s, vector&lt;vector&lt;bool&gt;&gt;&amp; isPalin, int i, int j) { while(i &gt;= 0 &amp;&amp; j &lt; len &amp;&amp; s[i] == s[j]) { isPalin[i][j] = 1; i--; j++; } } int minCut(string s) { if(s.empty()) return 0; len = s.size(); vector&lt;vector&lt;bool&gt;&gt; isPalin(len, vector&lt;bool&gt;(len,0)); for(int i = 0; i &lt; len; i++) { SearchPalin(s, isPalin, i, i); SearchPalin(s, isPalin, i, i+1); } vector&lt;int&gt; dp(len+1,INT_MAX); dp[0] = -1; for(int j = 0; j &lt; len; j++) { for(int i = j; i &gt;= 0; i--) { if(isPalin[i][j]) dp[j+1] = min(dp[j+1],1+dp[i]); } } return dp[len]; }}; 思路三 思路二中的方法需要用到$O(n^2)$的空间，事实上我们也可以用$O(1)$的空间实现同样的效果。（然而Leetcode给的内存消耗比思路二高了好多（大雾 1234567891011121314151617181920212223242526272829class Solution {private: int len;public: void helper(string s, int left, int right, vector&lt;int&gt;&amp; dp) { while(left &gt;= 0 &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right]) { if(left == 0) dp[right] = 0; else dp[right] = min (dp[right], dp[left-1] + 1); left--; right++; } } int minCut(string s) { if(s.empty()) return 0; len = s.size(); vector&lt;int&gt; dp(len,INT_MAX); for(int i =0 ; i &lt; len; i++) { helper(s,i,i,dp); helper(s,i,i+1,dp); } return dp.back(); }};","link":"/2020/01/30/leetcode132/"},{"title":"leetcode179","text":"最大数给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 虽然仅仅是一道中等难度的题，但是一开始还是有点懵。最开始的想法是设计一个类似从高位开始的基数排序。但在处理不同位长数的排序时，我发现很难给出一个统一的大小判别规律，例如$962,96,9$的最优排序是$996962$,而$162,16,1$的最优排序是$162161$。因此这个思路就只能毙掉了Orz。 官方提供的题解是定义一个新的比较逻辑bool cmp(string s1, string s2){s1+s2 &gt; s2+s1};，下面证明一下这个比较逻辑的正确性。 传递性 cmp(s1,s2) and cmp(s2,c3)$\\rightarrow$ cmp(s1,s3) Proof 假设$s_1,s_2,s_3$,长度分别为$l_1,l_2,l_3$，对应数分别为$n_1,n_2,n_3$。 s_1 + s_2 \\geq s_2 + s_1 \\rightarrow n_1l_2 + n_2 \\geq n_2l_1 + n_1\\\\ s_2 + s_3 \\geq s_3 + s_2 \\rightarrow n_2l_3 + n_3 \\geq n_3l_2 + n_2\\\\ n_1(l_2 - 1) \\geq n_2(l_1 - 1)\\\\ n_2(l_3 - 1) \\geq n_3(l_2 - 1)\\\\ 因为(3)(4)式左右均非负，可得 n_1n_2(l_2-1)(l_3-1) \\geq n_2n_3(l_1-1)(l_2-1) 如果$l_2 = 1$，由(3)可知$l_1 = 1$ n_1(l_3-1) \\geq 0 = n_3(l_1-1) 如果$l_2 \\neq 1$，由(5)可得 n_1(l_3-1) \\geq n_3(l_1-1)综上均有 n_1(l_3-1) \\geq n_3(l_1-1)即 s_1+s_3 \\geq s_3 + s_1 算法正确性 Proof 如若不然，存在一个最优序列含逆序对$s_2,s_1$（cmp(s1,s2) = true）。假设该逆序对之间的字符串为$s$。只需证明$s_1 + s +s_2 &gt; s_2 + s + s_1$，即可导出矛盾。 由于序列$s_1,s,s_2$经过了排序，有 s_1 + s \\geq s + s_1 \\rightarrow l n_1 + n \\geq l_1n + n_1\\\\ s + s_2 \\geq s_2 + s \\rightarrow l_2 n + n_2 \\geq l n_2 + n\\\\ s_1 + s_2 \\geq s_2+s_1 \\rightarrow l_2 n_1 + n_2 \\geq l_1 n_2 + n_1\\\\$(1)+(2)+l\\times (3)$，得 ll_2n_1 + l_2n +n_2 \\geq ll_1n_2 + l_1n +n_1等价于 s_1 + s +s_2 > s_2 + s + s_1综上证毕。 事实上，这道题的关键并不在于代码的实现上，算法正确性的证明显然更加重要。浏览了一下中文站的评论区几乎没有提到这一点，说明很多人在这上面还是模棱两可的，这也违背了我们做算法题的初衷，固以此作为补充。","link":"/2020/02/08/leetcode179/"},{"title":"leetcode135","text":"分发糖果老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 思路一 看到这道题就开始脑补一段分数变化的折线图。显然我们特别需要关注的是折线图的高峰和低谷，最理想的情况是每一个低谷的位置都是一颗糖果（如果一位同学夹在俩大佬之间真是有够惨的233） ，高峰处根据左右两侧的上升，选择较大的一者。根据这一思路，可以从左右两次遍历数组，每次给上升的一面赋值（包括峰值点）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution {public: int candy(vector&lt;int&gt;&amp; ratings) { if(ratings.empty()) return 0; int len = ratings.size(); int sum = 0; vector&lt;int&gt; candies(len, 1); bool up = 0; // Status: up //int pos = 0; //postition of base //up = ratings[1] &gt; ratings[0]; for(int i = 0 ; i &lt; len - 1; i++) { if(ratings[i] &lt; ratings[i+1]) { if(!up) { // reset base up = 1; candies[i] = 1; } candies[i+1] = candies[i] + 1; } else if(ratings[i] == ratings[i+1]) { if(up) candies[i+1] = 1; } else { if(up) up = 0; } } //up = ratings[len-1] &lt; ratings[len-2]; up = 0; for(int i = len -1; i &gt;= 1; i--) { if(ratings[i] &lt; ratings[i-1]) { if(!up) { candies[i] = 1; up = 1; } if(candies[i-1] &lt; candies[i] + 1) candies[i-1] = candies[i] + 1; } else if(ratings[i-1] == ratings[i]) { if(up &amp;&amp; candies[i-1] &lt; 1) candies[i-1] = 1; } else { if(up) up = 0; } sum += candies[i]; } sum += candies[0]; return sum; }}; 思路二 事实上，当candies数组已经被初始化为1时，我根本无需去对相等的情况进行特别的考虑，所以up这个变量就不再必要了。精简一下代码可以得到。 123456789101112131415161718192021222324class Solution {public: int candy(vector&lt;int&gt;&amp; ratings) { if(ratings.empty()) return 0; int len = ratings.size(); int sum = 0; vector&lt;int&gt; candies(len, 1); for(int i = 0; i &lt; len - 1; i++) { if(ratings[i] &lt; ratings[i+1]) candies[i+1] = candies[i] + 1; } for(int i = len - 1; i &gt;= 1; i--) { if(ratings[i] &lt; ratings[i-1]) candies[i-1] = max(candies[i] + 1, candies[i-1]); sum += candies[i]; } sum += candies[0]; return sum; }}; 思路三 思路三来自官方题解Orz。这个算法只需要用到常数的空间，思路本身并不难想到——通过考虑每一座山（一个峰）的上升次数和下降次数计算其消耗的最小糖果量。问题的关键在于如何细分每一次山的结束。 之前一次的状态下降，当前状态上升：当前的山结束，将谷底计入下一座山中 之前一次的状态下降，当前状态平行：由于两个相同分数的小孩之间没有糖果数量限制，事实上这时候也相当于来到一个谷底了，当前山结束。 之前一次的状态上升，当前状态下降：此时山开始步入下行，继续发展。 之前一次的状态上升，当前状态平行：类似情况2，相当于进入谷底，当前山结束。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int cal(int n ) { return n*(n+1)/2; } int candy(vector&lt;int&gt;&amp; ratings) { if(ratings.empty()) return 0; int len = ratings.size(); int sum = 0; int cur = 0; int last = 0; int up = 0; int down = 0; for(int i = 0; i &lt; len - 1; i++) { if(ratings[i+1] &gt; ratings[i]) cur = 1; else if(ratings[i+1] &lt; ratings[i]) cur = -1; else cur = 0; if((last == -1 &amp;&amp; cur &gt;= 0) || (last == 1 &amp;&amp; cur == 0)) { sum = sum + cal(up) + cal(down) + max(up,down); up = 0; down = 0; } if(cur == 1) up++; else if(cur == -1) down++; else sum++; last = cur; } sum = sum + cal(up) + cal(down) + max(up,down) + 1; //补上最后一个点的基数 return sum; }};","link":"/2020/01/30/leetcode135/"},{"title":"leetcode137","text":"只出现一次数字Ⅱ给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 设计一个状态转移电路使得三次转换后能回到原始状态00-&gt;01-&gt;10-&gt;00。 先整一个状态转移矩阵 a b x new_a new_b 0 0 1 0 1 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 1 0 画b的卡诺图 x\\ab 00 01 11 10 1 1 0 X 0 0 0 1 X 0 b = (b ^ x) &amp; ~a 画a的卡诺图 x\\ab 00 01 11 10 1 0 1 X 0 0 0 0 X 1 a = (x &amp; b) | (~x &amp; a) 12345678910111213class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int a = 0, b = 0; int tmp; for (auto x : nums) { tmp = b; b = (b ^ x) &amp; ~a; a = (x &amp; tmp) | (~x &amp; a); } return b; }}; 由于代码的实现中，每一位的计算并不是并行进行的，所以可以通过画一个行列由a,new_b,x构成的卡诺图来利用先生成的位。 x\\a new_b 00 01 11 10 1 1 0 X 0 0 0 0 X 1 a = (x ^ a) &amp; ~ new_b 12345678int singleNumber(vector&lt;int&gt;&amp; nums) { int a = 0, b = 0; for (auto x : nums) { b = (b ^ x) &amp; ~a; a = (a ^ x) &amp; ~b; } return b;}","link":"/2020/01/31/leetcode137/"},{"title":"leetcode164","text":"最大间距给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。 如果数组元素个数小于 2，则返回 0。 （请尝试在线性时间复杂度和空间复杂度的条件下解决此问题） 常规的排序时间复杂度为$O(n \\log n)$。 基数排序针对这个问题，考虑到数的范围给定，可以采用基数排序得到一个$O(n)$的算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {private: int getIndex(int&amp; num, int&amp; exp) { return (num / exp) % 10; }public: int maximumGap(vector&lt;int&gt;&amp; nums) { if(nums.size() &lt; 2) return 0; int Max = INT_MIN; for(auto&amp; num: nums) Max = max(num, Max); int exp = 1; vector&lt;int&gt; tmp(nums.size(), 0); while(Max / exp) { vector&lt;int&gt; count(10,0); for(auto&amp; num: nums) { count[getIndex(num, exp)]++; } for(int i = 1; i &lt; 10; i++) { count[i] += count[i-1]; } for(int i = nums.size() - 1; i &gt;=0; i--) { tmp[--count[getIndex(nums[i], exp)]] = nums[i]; } for(int i = 0; i &lt; nums.size(); i++) nums[i] = tmp[i]; exp *= 10; } int res = 0; for(int i = 0; i &lt; nums.size() - 1; i++) { res = max(res, nums[i+1] - nums[i]); } return res; }}; 桶排序桶排序的关键在于如何设置一个合理桶大小，最糟糕的情况是每个元素一个桶，这在元素之间大小差异过大时，无论是时间还是空间的开销都是过于昂贵的 假设有一个含$N$个元素的数组，最大值是$Max$,最小值是$Min$。那么其最大间距的最小值应该为$\\lfloor \\frac{(Max - Min)}{(N-1)}\\rfloor + 1$（均匀分散的时候取到）。这就启发我们及那个桶的大小设置成$\\lfloor \\frac{(Max - Min)}{(N-1)}\\rfloor + 1$。如此一来，我们的关注重点只需放在临近的桶上而不需要考虑桶内间距（这是因为桶内间距小于最大间距的最小值，没有参考价值）。 具体来说，可以给每个桶设置一个最大值，和最小值。每一次的比较只需要在上一个桶的最大值与当前桶的最小值之间进行（没有元素的桶跳过）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {private: int Max, Min; int bucketNum; int bucketSize; int getIndex(int&amp; num) { return (num - Min) / bucketSize; }public: int maximumGap(vector&lt;int&gt;&amp; nums) { if(nums.size() &lt; 2) return 0; Max = INT_MIN; Min = INT_MAX; for(auto&amp; num: nums) { Max = max(Max, num); Min = min(Min, num); } if(nums.size() == 2) return Max-Min; bucketSize = (Max - Min) / (nums.size() - 1)+1; bucketNum = (Max - Min) / bucketSize; //cout &lt;&lt; bucketSize &lt;&lt; ' ' &lt;&lt; bucketNum; vector&lt;int&gt; bucketMax(bucketNum+1, INT_MIN); vector&lt;int&gt; bucketMin(bucketNum+1, INT_MAX); for(auto&amp; num: nums) { int idx = getIndex(num); bucketMax[idx] = max(bucketMax[idx], num); bucketMin[idx] = min(bucketMin[idx] ,num); } int pre = INT_MAX; int gap = 0; for(int i = 0; i &lt;= bucketNum; i++) { if(bucketMax[i] == INT_MIN) continue; gap = max(gap, bucketMin[i] - pre); pre = bucketMax[i]; } return gap; }};","link":"/2020/02/05/leetcode164/"},{"title":"leetcode149","text":"支线上最多的点数给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。 从一个基点出发，遍历其他的点（$O(n^2)$），分别计算 与基点重合点的数量（same） 经过基点不同斜率的直线上的点数（dict[slope]） 取第一项的值与第二项中的最大值（max_count）之和为基点对应极大值，在遍历过程中更新结果。 我们的遍历是建立在确定的基点上的，因此只需斜率就可以唯一确定一条直线。考虑到浮点数的精度问题，我转而考虑用辗转相除法将dx,dy约化为最简形式并以pair的形式存储。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {private: // x &lt; y int gcd(int x, int y) { return x == 0 ? y : gcd(y % x, x); } pair&lt;int,int&gt; getSlope(int x1, int y1, int x2, int y2) { int dx = x1 - x2; int dy = y1 - y2; if(dy == 0) return {y1, 0}; if(dx == 0) return {0, x1}; int d = gcd(dx, dy); return {dy / d, dx / d}; }public: int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if(points.size() &lt; 3) return points.size(); int len = points.size(); //int same = 0; int res = 2; for(int i = 0; i &lt; len; i++) { int same = 1; int max_count = 0; map&lt;pair&lt;int,int&gt;, int&gt; dict; for(int j = i+1; j &lt; len; j++) { if(points[j][0] == points[i][0] &amp;&amp; points[j][1] == points[i][1]) { same++; } else { pair&lt;int, int&gt; slope = getSlope(points[i][0], points[i][1], points[j][0], points[j][1]); if(!dict.count(slope)) dict[slope] = 1; else dict[slope]++; max_count = max(max_count, dict[slope]); } } res = max(res, same + max_count); } return res; }};","link":"/2020/02/03/leetcode149/"},{"title":"leetcode148","text":"排序链表在 $O(n \\log n)$ 时间复杂度和常数级空间复杂度下，对链表进行排序。 注意到常数空间复杂度，递归的算法就可以先排除掉了。 一个简单的想法是自下而上地归并，函数cut(head, step)从头部截取step长度的子列表并返回下一段列表的起始节点。merge合并两个列表并返回尾部节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {private: ListNode* cut(ListNode* head, int step) // divide a sublist with length 'step' off the list { if(!head) return NULL; ListNode* p = head; while(p-&gt;next &amp;&amp; step-1) { p = p-&gt;next; step--; } ListNode *tmp = p-&gt;next; p-&gt;next = NULL; return tmp; } ListNode* merge(ListNode* r, ListNode* list1, ListNode* list2) { ListNode* p = list1; ListNode* q = list2; while(p || q) { if(!q) { r-&gt;next = p; while(p-&gt;next) p = p-&gt;next; return p; } else if(!p) { r-&gt;next = q; while(q-&gt;next) q = q-&gt;next; return q; } if(p-&gt;val &gt; q-&gt;val) { r-&gt;next = q; q = q-&gt;next; } else { r-&gt;next = p; p = p-&gt;next; } r = r-&gt;next; r-&gt;next = NULL; } return r; }public: ListNode* sortList(ListNode* head) { if(!head) return NULL; ListNode* dum = new ListNode(-1); dum-&gt;next = head; int step = 1; ListNode* pre = dum; ListNode* cur = head; int cnt = 0; while(1) { pre = dum; cur = dum-&gt;next; cnt = 0; while(cur) { ListNode* first = cur; ListNode* second = cut(cur, step); cur = cut(second, step); pre = merge(pre, first, second); cnt++; } if(cnt == 1) break; step *= 2; } return dum-&gt;next; }};","link":"/2020/02/03/leetcode148/"},{"title":"同时在Github与Coding上部署Hexo","text":"配置SSH公钥我们可以通过SSH公钥来访问仓库，生成公钥的操作如下（配置的过程默认即可） 1ssh-keygen -t rsa -C &lt;your_email@example.com&gt; 将生成的id_rsa.pub内容添加到Coding与Github的SSH公钥即可。 之后我们就可以直接对仓库进行操作，而不需要输入用户名和密码了，例如 12git@git.coding.net:Gavin_liudu/Gavin_liudu.coding.me.gitgit@github.com:SJTUGavinLiu/SJTUGavinLiu.github.io.git 之后在blog根目录下的_config.yml中如下设置即可 12345deploy: type: git repo: github: https://github.com/SJTUGavinLiu/SJTUGavinLiu.github.io.git,master coding: git@git.coding.net:Gavin_liudu/Gavin_liudu.coding.me.git,master 个人域名绑定在阿里云的域名列表中加入记录 主机记录www，记录类型A，记录值是IP地址， 设置主机记录@，记录类型CNAME，记录值是Page页面地址 文本内的图片插入一开始有考虑用图床来实现图片的中转，但是有两个问题还是让我放弃这一个想法 图床存在挂掉的可能性（图床挂了，页面里的图片就全崩了，恢复极其麻烦） 由于我平时习惯用typora来写一些内容，所以图片都默认使用相对路径的形式在文本中进行标识。图床多出了上传图片并修改文本中图片地址的过程，实在麻烦 因此我还是选择了把图片存在了source/images/的路径下，通过相对路径的形式调取。 GIT LFS的引入Git在存储二进制文件，例如音频，图像，视频等的时候效率不高，因为Git默认会压缩并存储二进制文件的所有完整版本。由于我选择将图片存入仓库中，随着博文数量的增加，Git仓库文件会不断地增长，最终超出容量的上界。 针对这个问题，Git-LFS提供了一个合理的解决方案，即只在真正的Git仓库中保存二进制文件的哈希等数据，而将真实的文件存储在GIT-LFS的服务器上。 Git LFS的处理方式类似于.gitignore 12git lfs installgit lfs track \"*.png\" 一切似乎都非常美好，然而悲伤的是，我的博客是基于Github/Coding Page的，所以图片必须上传到repo里，否则似乎无法显示QAQ，因此Git-LFS的方案只能暂时弃置。 Typora与Hexo的对接整了一个小脚本，可以把Typora中写好的东西打上分类，标签导入_post文件夹里（包括图片）详见Typora2hexo.py","link":"/2020/01/18/同时在Github与Coding上部署Hexo/"},{"title":"leetcode174","text":"地下城游戏一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。 为了尽快到达公主，骑士决定每次只向右或向下移动一步。 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。 -2（K） -2 3 -5 -10 1 10 30 -5（P） 说明: 骑士的健康点数没有上限。 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。 DFS​ 这道题可以看作是一个路径搜索问题，因此DFS肯定是可以解决的，只需要在回溯的过程中，维护当前路径上曾达到的最低健康值，以及当前位置的健康值即可。当然，由于过于暴力，某些case超时了Orz。 动态规划​ 动态规划的核心在于状态转移方程。对于动态规划来说，当前的最优状态仅由之前的状态决定，不会受到后面发生的事件的影响。当我们正向考虑这个问题时会发现，我们无法在不知道未来信息的情况下对当前状态做出决断。这是因为，前面的状态包含两个信息：当前路径上曾达到的最低健康值（也是我们的计算目标），当前位置的健康值。假设未来的路径中均为健康回复点，那么毫无疑问我们要选择当前路径上曾达到的最低健康值大的一者。而如果未来的路经中存在健康掉落点，那么我们可能需要选择当前位置健康值大的一者，这取决于未来路径的”恶劣程度”。 ​ 正向的动态规划行不通，那么不妨尝试负向的策略。维护一个动态规划数组dp，其中dp[i][j]代表$(i,j)$处出发需要的最小健康值。显然dp[i][j]的最小值是1,可以得到状态转移方程则为dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])。 123456789101112131415161718192021222324class Solution {public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) { int height = dungeon.size(); int width = dungeon[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(height, vector&lt;int&gt;(width,0)); dp[height-1][width-1] = max(1, 1-dungeon[height-1][width-1]); for(int i = height-2; i &gt;= 0; i--) dp[i][width-1] = max(1, dp[i+1][width-1] - dungeon[i][width-1]); for(int j = width - 2; j &gt;= 0; j--) dp[height-1][j] = max(1, dp[height-1][j+1] - dungeon[height-1][j]); for(int i = height -2; i &gt;= 0; i--) { for(int j = width - 2; j &gt;= 0; j--) { dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j]) - dungeon[i][j]); } } return dp[0][0]; }}; ​ 在此基础上，可以压缩一下空间。 1234567891011121314151617181920212223class Solution {public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) { int height = dungeon.size(); int width = dungeon[0].size(); vector&lt;int&gt; dp(width, 0); dp[width-1] = max(1, 1-dungeon[height-1][width-1]); for(int j = width - 2; j &gt;= 0; j--) dp[j] = max(1, dp[j+1] - dungeon[height-1][j]); for(int i = height -2; i &gt;= 0; i--) { dp[width - 1] = max(1, dp[width-1] - dungeon[i][width-1]); for(int j = width - 2; j &gt;= 0; j--) { dp[j] = max(1, min(dp[j+1], dp[j]) - dungeon[i][j]); } } return dp[0]; }}; 时间复杂度$O(mn)$, 空间复杂度$O(n)$","link":"/2020/02/06/leetcode174/"},{"title":"博客开张","text":"「Gavin的碎碎念~」开张^^关于为什么开这个博客平时也会用Typora写一些东西，写的多了，查阅起来就不是很方便了。因此我就想到利用Hexo+Github Page建立一个静态博客，一方面省去了服务器的开支，另一方面可以利用现成的模板设计去实现类似于查找，归类，时间线的功能，省去了自己重复开发的时间。没有的功能自己魔改也并不麻烦。于是乎，「Gavin的碎碎念~」就诞生了：） 博客里会有些啥嘞所谓碎碎念，就是啥都会谈一些。内容不局限于以下 技术文档（最近在刷leetcode可能也会写一些例题相关ORZ） 生活分享与一些小随笔 游戏的体验评测（八方旅人ing，或许也会有音乐，电影，书籍这些，根本就很少看书了好伐） 练琴（Guitar &amp; Keyboard）的心得体会以及一些基础乐理的笔记 flag Finally从「Gavin的碎碎念~」开始，养成做完事后复盘的好习惯，接受一切监督QAQ。绝不咕咕咕。","link":"/2020/01/17/博客开张/"},{"title":"leetcode152","text":"乘积最大子序列给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 注意到三个事实。 含0的序列，$\\min \\max\\limits{i,j} \\mathop{mul}(l{ij}) = 0$ 。($l_{ij}$指子序列nums[i,j]) 经过0的子序列乘积为0 不含0且至少有一个正数的序列的最大乘积子序列里含偶数个负数。 考虑到FACT 2，我们将序列拆分成不含0的子列分别考虑。 如果子列含有的负数个数为偶数，其子序列乘积最大值就是其本身乘积最大值。 如果子列含有的负数个数为奇数，如下所示 ${…,a1,…….., a{2k+1},…}$，（${a_n}$ 为负数数列） 其子序列乘积最大值为序列${…,a1,…,a{2k+1}} / {a{2k+1}}$与序列${a_1,…,a{2k+1},…} / {a_{1}}$二者中的乘积较大者。这是因为 子序列长度增加，乘积单调不减。 不含0且至少有一个正数的序列的最大乘积子序列里含偶数个负数。 针对这种情况，我们可以左右遍历，分别计算累积的最大乘积，取较大值即可。 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int maxProduct(vector&lt;int&gt;&amp; nums) { int res = nums[0]; int i = 0; while(i &lt; nums.size()) { while(i &lt; nums.size() &amp;&amp; nums[i] == 0) i++; int j = i; int cnt = 1; while(j &lt; nums.size() &amp;&amp; nums[j] != 0) { cnt *= nums[j]; res = max(res, cnt); j++; } if(j &lt; nums.size()) res = max(res, 0); int tmp = i; i = j; j--; cnt = 1; while(j &gt;= tmp) { cnt *= nums[j]; res = max(res, cnt); j--; } } return res; }};","link":"/2020/02/04/leetcode152/"},{"title":"模拟退火算法","text":"模拟退火算法 Simulated Annealing爬山算法在讨论SA之前，我们先简单谈一下爬山算法。爬山算法的思想很简单，它是一个纯粹的贪心算法，每次从当前解的邻近空间寻找一个最优解直到达到局部最优。它的问题很明显，完全的贪婪使得它并不保证能得到全局的最优解。 如何解决爬山算法存在的问题事实上，一味地选取邻域上的最优解并不是一个好的选择。在搜索的初始阶段，我们对整个函数没有任何的感知，此时如果完全地采用贪婪策略，很有可能落在一个局部最优地的解里。为了避免这一情况的发生，我们应该在前期适当地去接纳一些看上去不是那么美好的解，以达到更好地感知函数整体状况的目的。这和强化学习里的Exploration和Exploitation权衡的思想是一致的。 模拟退火算法Metropolis准则假设在状态$x{old}$时系统受到某种扰动而使其状态变为$x{new}$。与此相对应，系统的能量也从$E(x{old})$变成$E(x{new})$，系统由状态$x{old}$变为状态$x{new}$的接受概率p： p = \\begin{cases} 1 & if \\space E(x_{new}) < E(x_{old})\\\\ exp(-\\frac{E(x_{new}) - E(x_{old})}{T}) & if \\space E(x_{new}) \\geq E(x_{old})\\\\ \\end{cases}算法实现 算法细节 邻域候选解可以用均匀分布，正态分布，指数分布的概率密度函数对解空间进行随机采样来获得。 状态转移概率（p），反映了是否接受当前解的概率，采用Metropolis准则。 冷却进度表$T(t)$ 经典模拟退火算法的降温方式$T(t) = \\frac{T_0}{\\lg(1+t))}$ 快速模拟退火算法的降温方式$T(t) = \\frac{T_0}{1+t}$ 初始温度$T_0$，从理论上讲，初温越大，获得高质量解的几率越大，但花费的计算时间将增加 均匀抽样一组状态，以各状态目标值的方差为初温。 随机产生一组状态，确定两两状态间最大目标值差，依据差值，利用一定的函数确定初温，比如$t0 = -\\Delta{max}/p_r$,其中$p_r$为初始接受概率。 内循环终止准则-Metropolis抽样稳定准则，用于决定在各温度下产生候选解的数目。常用的抽样稳定准则包括： 检验目标函数的均值是否稳定 连续若干步的目标值变化较小 按一定的步数抽样","link":"/2020/02/08/模拟退火算法/"},{"title":"leetcode207","text":"课程表现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 拓扑排序 Topological Order: A topological order of a directed graph G = (V, E) is an ordering of itsnodes as $v_1,..,v_n$ so that for every edge $(v_i,v_j)$ we have for $i&lt;j$. 拓扑排序的一个经典应用案例。 关于拓扑排序有一个重要结论——一个有向图存在拓扑排序的充分必要条件是该图不存在有向环（DAG）。这个结论的具体证明由一下几个引理构成。 Lemma1. If G has a topological ordering, then G is a DAG 引理1通过构造矛盾容易证明。 Lemma2. If G is DAG, then G has a node with no entering edges. 如果每个点入度均大于0，由于节点数有限，总是能找到一个环，矛盾！ Lemma3. If G is DAG, then G has a topological ordering. 递归构造 Base: n = 1 时，显然正确 若n = k时，结论成立。 n = k+1时，由Lemma1可以找到一个入度为0的节点v。G - { v } 是DAG（DAG删掉一个点显然还是DAG），由归纳假设得存在一个拓扑排序。因为v的入度为0，将v放在该排序前方即可得到一个有效排序。 算法实现顺着证明的思路，我们不难发现，算法的关键就在入度为0的这些节点上。我们只需要不断地找出当前图中入度为0的点，并将其删除，更新其余点的入度即可确定该图是否存在拓扑排序。这是一个典型的贪心思想。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { vector&lt;vector&lt;int&gt;&gt; ajac(numCourses, vector&lt;int&gt;()); vector&lt;int&gt; indegree(numCourses, 0); queue&lt;int&gt; qu; int cnt = 0; for(auto&amp; pre: prerequisites) { ajac[pre[1]].push_back(pre[0]); indegree[pre[0]]++; } for(int i = 0; i &lt; numCourses; i++) { if(indegree[i] == 0) { qu.push(i); cnt++; } } while(!qu.empty()) { int cur = qu.front(); qu.pop(); for(int&amp; succ: ajac[cur]) { indegree[succ]--; if(indegree[succ] == 0) { cnt++; qu.push(succ); } if(cnt == numCourses) return true; } } return cnt == numCourses; }};","link":"/2020/02/10/leetcode207/"},{"title":"leetcode209","text":"长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 思路一 基于贪心的想法，我们从左右两边向中间逼近，当当前子序列的和仍大于s，则扔掉左右两端较小的数，知道子序列的和小于s。这是我拿到题的第一个思路，但很遗憾，它并不能保证得到最优解。考虑一个数组$[3,1,1,1,…,2,2,2]$，假设这个数组的和是$s+6$，根据判定规则，我们会将右指针左移三个单位。而事实上，最优的解法是将左指针右移四个单位。 思路二 仍然是基于贪心的想法，我们维护一个滑动窗口来描述子序列。 当子序列大于等于s时，更新最优解，并将左指针右移。 当子序列小于s时，右指针右移。 那么这个思路是否能保证得到最优解呢，答案是肯定的。事实上我们在这个过程中查询了以每个节点为起始点的最小序列。 1234567891011121314151617181920212223class Solution {public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) { int left = 0,right = 0; int len = nums.size(); int sum = 0; int res = INT_MAX; while(right &lt; len) { while(sum &lt; s &amp;&amp; right &lt; len) { sum+=nums[right++]; } while(sum &gt;= s) { res = min(res, right-left); sum -= nums[left++]; } } return res == INT_MAX ? 0 : res; }};","link":"/2020/02/11/leetcode209/"},{"title":"前缀树","text":"前缀树 TrieTrie树是一个有根的树，其结点具有以下字段： $R$个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母 bool字段，标定该结点是否为一个单词的结尾 支持加入新字符串，查找字符串以及查找前缀的功能，其中时间复杂度均为$O(n)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class TrieNode {private: TrieNode* next[26]{NULL}; bool isEnd = false;public: TrieNode(){} TrieNode* get(char c) { return next[c - 'a']; } TrieNode* insert(char c) { if(!next[c - 'a']) next[c - 'a'] = new TrieNode(); return next[c - 'a']; } void set_end() { isEnd = true; } bool is_end() { return isEnd; }};class Trie {private: TrieNode* root;public: /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode* cur = root; for(char c: word) { cur = cur-&gt;insert(c); } cur-&gt;set_end(); } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode* cur = root; for(char c: word) { cur = cur-&gt;get(c); if(!cur) return false; } return cur-&gt;is_end(); } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { TrieNode* cur = root; for(char c: prefix) { cur = cur-&gt;get(c); if(!cur) return false; } return true; }};","link":"/2020/02/11/前缀树/"},{"title":"leetcode212","text":"单词搜索Ⅱ给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。 暴力的解法就是对每一个单词在每一个位置做一遍DFS。这样做的开销很大，因为我们独立考虑了每一个单词而不是把单词列表作为整体来考虑。想到这里，我的直觉是寻找一个线性表之外的数据结构来存储单词列表以实现整体搜索，而Leetcode208中提到的前缀树就是一个好的选择。 我们可以提前将单词列表存入一个前缀树中，之后遍历每一个位置进行DFS。在DFS的过程中，我们同步移动前缀树结点与board上的位置这样我们就实现了同时查询前缀树上所有单词的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class TrieNode {private: TrieNode* next[26]{NULL}; bool isEnd = false; string word;public: TrieNode(){} TrieNode* get(char c) { return next[c - 'a']; } TrieNode* insert(char c) { if(!next[c - 'a']) next[c - 'a'] = new TrieNode(); return next[c - 'a']; } void set_end() { isEnd = true; } bool is_end() { return isEnd; } void set_word(string s) { word = s; } string get_word() { return word; }};class Solution {private: vector&lt;string&gt; res; unordered_set&lt;string&gt; hash_set; int height,width; bool isValid(int i, int j) { return i &gt;= 0 &amp;&amp; i &lt; height &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; width; } void dfsSearch(TrieNode* cur, int i, int j, vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; mark) { cur = cur-&gt;get(board[i][j]); if(!cur) return; if(cur-&gt;is_end()) { string tmp = cur-&gt;get_word(); if(!hash_set.count(tmp)) { res.push_back(tmp); hash_set.insert(tmp); } } mark[i][j] = false; i -= 1; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark); i += 2; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark); i -= 1; j -= 1; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark); j += 2; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark); j -= 1; mark[i][j] = true; } public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) { height = board.size(); width = board[0].size(); vector&lt;vector&lt;bool&gt;&gt; mark(height, vector&lt;bool&gt;(width, 1)); TrieNode* root = new TrieNode(); for(auto&amp; word: words) { TrieNode* cur = root; for(auto&amp; c: word) { cur = cur-&gt;insert(c); } cur-&gt;set_end(); cur-&gt;set_word(word); } for(int i = 0; i &lt; height; i++) { for(int j = 0; j &lt; width; j++) { dfsSearch(root, i, j, board, mark); } } return res; }}; 在此基础上还有一个小细节可以优化。由于单词列表是给定的，事实上我们可以用对应的index的形式来唯一指定对应的单词，这样一来，我们就可以用普通的数组来记录当前单词是否被查询到过，而避免了使用哈希表时间和空间上都有所节省。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108class TrieNode {private: TrieNode* next[26]{NULL}; bool isEnd = false; int word = -1;public: TrieNode(){} TrieNode* get(char c) { return next[c - 'a']; } TrieNode* insert(char c) { if(!next[c - 'a']) next[c - 'a'] = new TrieNode(); return next[c - 'a']; } void set_end() { isEnd = true; } bool is_end() { return isEnd; } void set_word(int s) { word = s; } int get_word() { return word; }};class Solution {private: vector&lt;string&gt; res; int height,width; bool isValid(int i, int j) { return i &gt;= 0 &amp;&amp; i &lt; height &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; width; } void dfsSearch(TrieNode* cur, int i, int j, vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; mark, vector&lt;string&gt;&amp; words, vector&lt;bool&gt;&amp; found) { cur = cur-&gt;get(board[i][j]); if(!cur) return; if(cur-&gt;is_end()) { int idx = cur-&gt;get_word(); //cout&lt;&lt; idx &lt;&lt;endl; if(!found[idx]) { res.push_back(words[idx]); found[idx] = 1; } } mark[i][j] = false; i -= 1; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark, words, found); i += 2; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark, words, found); i -= 1; j -= 1; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark, words, found); j += 2; if(isValid(i,j) &amp;&amp; mark[i][j]) dfsSearch(cur, i, j, board, mark, words, found); j -= 1; mark[i][j] = true; } public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) { height = board.size(); width = board[0].size(); vector&lt;vector&lt;bool&gt;&gt; mark(height, vector&lt;bool&gt;(width, 1)); vector&lt;bool&gt; found(words.size(), 0); TrieNode* root = new TrieNode(); for(int i = 0; i &lt; words.size(); i++) { TrieNode* cur = root; for(auto&amp; c: words[i]) { cur = cur-&gt;insert(c); } cur-&gt;set_end(); cur-&gt;set_word(i); } for(int i = 0; i &lt; height; i++) { for(int j = 0; j &lt; width; j++) { dfsSearch(root, i, j, board, mark, words, found); } } return res; }};","link":"/2020/02/11/leetcode212/"},{"title":"KMP","text":"KMP算法问题背景如何在文本中寻找目标字符串? Brute Force如何在一个字符串text中寻找目标字符串target，最简单的思路是从text的第一个字符出发逐个匹配，如果失配则移动到text的下一个位置，从头开始匹配字符串target。但这样做的问题是显然的——对于text中的每一个位置我们都需要从头开始匹配。换言之，每一次匹配都是一个独立的进程，并没有利用到之前匹配过程中获得的潜在信息。那么是否有办法利用匹配过程中积累的信息来对后续的匹配进行一定的优化呢？答案就是KMP。 KMPTerminology 前缀：a,ab,abc均是abcd的前缀 后缀：d,cd,bcd均是abcd的后缀 公共最大长，前缀集合与后缀集合交集中最长的字符串的长度。例如ababa的公共最大长是3，对应aba 前后缀不能是它们本身 求公共最大长现在我们对target头部到其任意位置的子串计算最大公共最大长（为啥要算这个之后会解释）。这里我们用动态规划进行处理，因此我们需要找到一个合适的状态转移方程。举一个例子 index 0 1 2 3 4 5 target a b c a b record 0 0 0 1 2 已知index 0~4的公共最大长，求index 5的情况。先考察0-4的字串, 如果0-4的公共最大前后缀加上target[5]为符合0-5子串前后缀，则0-5的公共最大长为record[4]+1（如若不然，可以得到0-4的更长公共前后缀，矛盾） 如果不符合，将考察对象转移到0-4子串的最大公共前后缀上，如此循环，直到找到合适的前后缀或考察对象落在了单字符子串上。 具体算法实现如下 123456789101112131415void get_pre_post_len(string s, vector&lt;int&gt;&amp; record){ record[0] = 0; //单字符字符串没有公共前后缀 for(int i = 1; i &lt; s.size(); i++) { int j = record[i-1]; while(s[j] != s[i] &amp;&amp; j &gt; 0) j = record[j-1]; record[i] = j + (s[j] == s[i]); } //for(int i = 0; i &lt; s.size(); i++) // cout &lt;&lt; record[i] &lt;&lt; '\\t';} 利用最大公共长数组优化搜索同样举一个例子（随手在网上抓了一个，不想作图，懒） 可以看到字符串在index为5的位置失配了，如果是BF算法，我们就只是保守地将目标串右移一格。然而由于我们已经知道了每个子字符串的公共最大前后缀，我们可以做更大幅度的移动，如下所示。 123456789101112131415161718192021222324bool kmp(string text, string target){ vector&lt;int&gt; record(target.size(), 0); get_pre_post_len(target, record); int i = 0; int j = 0; while((i+target.size()) &lt;= text.size()) { while(j &lt; target.size()) { if(target[j] != text[i+j]) { i = i + j - record[j-1]; j = record[j-1]; break; } j++; } if(j == target.size()) return true; } return false;}","link":"/2020/02/12/KMP/"},{"title":"Manacher","text":"Manacher算法问题背景给定一个字符串，求出其最长回文子串 中心扩展一个常规的思路是从给定字符串每个位置的中心展开，这个算法的时间复杂度是$O(n^2)$。类似于我在讨论KMP算法时的直觉，我们希望从每个位置中心展开搜索时能够根据之前搜索得到的潜在信息来优化当前搜索的起始位置。 Manacher数据预处理我们在处理回文串的过程中，经常要面对的一个问题就是奇回文串与偶回文串的区分。关于这个问题我们通常有两个方法 用两个点坐标指代回文串的中心，其中$(i,i)$ 代表奇回文串的中心，$(i,i+1)$代表偶回文串的中心。 在原字符串的字符间插入占位符（占位符在字符串中不能出现） 这里我就直接使用第一种表示方式来实现Manacher算法。 Manacher的关键在于维护当前能搜索到的最远距离mx以及达到这个距离的子串中心id（包含两个坐标点id1,id2），当我们当前探索的点i小于mx时，我们可以找到它关于中心id的对称点j，用由它展开的回文串长度来初始化当前的搜索radius = min(mx-i,p[j])（p存放每一个位置展开的回文串的长度）。当然这里我们希望子串的中心能唯一对应数轴上的一个点，因此设计一个编码函数int encode(int i, int j){return i+j}将两个坐标点转换为唯一对应的一个坐标点。 算法的实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;vector&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;#define encode(i, j) ((i)+(j))class manacher {private: int id; int mx; int Max; void helper(int fir, int sec, vector&lt;int&gt;&amp; p, string&amp; s) { int cur = encode(fir, sec); if(sec &lt; mx) p[cur] = min(p[2*id - cur],mx-sec); else p[cur] = fir == sec; while(fir-p[cur] &gt;= 0 &amp;&amp; sec+p[cur] &lt; s.size() &amp;&amp; s[fir-p[cur]] == s[sec+p[cur]]) p[cur]++; p[cur]--; Max = max(Max, 2*p[cur]+1+(fir!=sec)); if(sec + p[cur] &gt; mx) { mx = sec + p[cur]; id = encode(fir,sec); } }public: manacher() {} int algo(string text) { vector&lt;int&gt; p(text.size()*2, 0); id = 0; mx = 0; Max = 0; for(int i = 0; i &lt; text.size(); i++) { helper(i,i,p,text); helper(i,i+1,p,text); } return Max; }};int main(){ manacher obj; cout &lt;&lt; obj.algo(\"abbabhcbapbchopxo\");} 基于第二种表示回文串中心方式的算法如下（不是俺写的），作为补充 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152char s[1000];char s_new[2000];int p[2000];int Init(){ int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++) { s_new[j++] = s[i]; s_new[j++] = '#'; } s_new[j] = '\\0'; // 别忘了哦 return j; // 返回 s_new 的长度}int Manacher(){ int len = Init(); // 取得新字符串长度并完成向 s_new 的转换 int max_len = -1; // 最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) { if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); // 需搞清楚上面那张图含义, mx 和 2*id-i 的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) // 不需边界判断，因为左有'$',右有'\\0' p[i]++; // 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) { id = i; mx = i + p[i]; } max_len = max(max_len, p[i] - 1); } return max_len;} 算法的复杂度分析Manacher算法为线性算法，即使最差情况下时间复杂度亦为$O(n)$。 证明并不困难，考虑到我们计算p[i]的时候，只有如下几种情况 i落在id展开的范围内，其镜像点j的回文串半径p[j]满足i + p[j] &lt; mx i落在id展开的范围内，其镜像点j的回文串半径p[j]满足i + p[j] &gt;= mx i落在id展开的范围外，p[i]从1开始搜索。 对于第一种情况，无需进行额外的搜索即可更新p[i]的值；对于第二种情况，搜索的同时，也同步更新了mx的值；对于第三种情况，同于第二种情况。 由上可以看出，我们每次进行搜索时都同步推进了mx的大小。换言之，我们搜索的步数正好与mx相等。因此这是一个线性算法。","link":"/2020/02/13/Manacher/"},{"title":"leetcode214","text":"最短回文串给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 这道题本质上是要求出给定字符串的最大回文子串，不同之处在于，该字串要求从给定字符串的头部开始截取。 中心扩展算法中心扩展$O(n^2)$在面对重复连续字符较多的字符串效率极低。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {private: int Max = INT_MIN; int left; int right; int radius; void helper(int l, int r, string&amp; s) { int i = l; int j = r; while(i &gt;= 0 &amp;&amp; j &lt; s.size()) { if(s[i] != s[j]) break; i--; j++; } if( i == -1 &amp;&amp; (j-i-1) &gt; Max) { Max = j - i -1; left = l; right = r; radius = j - r - 1; } }public: string shortestPalindrome(string s) { int len = s.size(); for(int i = 0; i &lt; len; i++) { helper(i,i,s); helper(i,i+1,s); } string res = s; int l = left - radius; int r = right + radius; r++; while(r &lt; len) { res = s[r] + res; r++; } return res; }}; Manacher算法Manacher算法是解决回文串问题的一个很好的优化思路，（具体可以见于Manacher算法）。我们只需在原算法的基础上记录最优的子回文串，即可实现一个$O(n)$的算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define encode(i,j) ((i)+(j))class Solution {private: int id; int res1, res2; int Max = INT_MIN; int mx; void helper(int fir, int sec, vector&lt;int&gt;&amp; p, string&amp; s) { int cur =encode(fir, sec); if(sec &lt; mx) p[cur] = min(p[2*id - cur],mx-sec); else p[cur] = fir == sec; //cout &lt;&lt; (fir-p[cur] &gt;= 0 &amp;&amp; sec+p[cur] &lt; int(s.size()) &amp;&amp; s[fir-p[cur]] == s[sec+p[cur]]) &lt;&lt;endl; while(fir-p[cur] &gt;= 0 &amp;&amp; sec+p[cur] &lt; int(s.size()) &amp;&amp; s[fir-p[cur]] == s[sec+p[cur]]) p[cur]++; p[cur]--; if(fir - p[cur] == 0 &amp;&amp; Max &lt; (2 * p[cur] + 1 + (fir != sec))) { Max = 2 * p[cur] + 1 + (fir != sec); res1 = fir; res2 = sec; } if(sec + p[cur] &gt; mx) { mx = sec + p[cur]; id = encode(fir,sec); } }public: string shortestPalindrome(string s) { if(s.empty()) return s; //cout &lt;&lt; s.size() &lt;&lt;endl; res1=res2=0; id=0; mx=0; vector&lt;int&gt; p(s.size() + 2, 0); for(int i = 0; i &lt;= s.size()/2; i++) { helper(i, i, p, s); helper(i, i+1, p, s); } int i = res2 + p[encode(res1, res2)]+1; string res = s.substr(i, s.size() - i); reverse(res.begin(), res.end()); return res + s; }}; KMP算法KMP也是字符串领域的一个重要匹配算法（具体可以见于KMP算法），由此可以有一个新的思路——将原字符串求逆序，然后利用KMP算法进行交错区域的匹配。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {private: void getRecord(string&amp; s, vector&lt;int&gt; &amp; record) { for(int i = 1; i &lt; s.size(); i++) { int cur = record[i-1]; while(cur &gt; 0 &amp;&amp; s[i] != s[cur]) cur = record[cur-1]; record[i] = cur + s[i] == s[cur]; } }public: string shortestPalindrome(string s) { string t = s; reverse(t.begin(), t.end()); int i = 0; //指示字符串s int j = 0; //指示字符串t vector&lt;int&gt; record(s.size(), 0); getRecord(s, record); while(j &lt; t.size()) { while((j+i) &lt; t.size() &amp;&amp; s[i] == t[j+i]) i++; if((j+i) == t.size()) break; j = max(j+1,j + i - (i &gt; 0 ? record[i-1] : 0)); i = i &gt; 0 ? record[i-1] : 0; } return t.substr(0, j) + s; }};","link":"/2020/02/13/leetcode214/"},{"title":"leetcode218","text":"天际线问题城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线（图B）。 每个建筑物的几何信息用三元组 $[L_i，R_i，H_i]$ 表示，其中 $L_i$ 和 $R_i$ 分别是第 $i$ 座建筑物左右边缘的 x 坐标，$H_i$ 是其高度。可以保证 $0 ≤ L_i$, $R_i ≤ INT_MAX$, $0 &lt; H_i ≤ INT_MAX$ 和 $R_i - L_i &gt; 0$。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。 例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。 输出是以 $[ [x_1,y_1], [x_2, y_2], [x_3, y_3], … ]$ 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。 例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。 说明: 任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。输入列表已经按左 x 坐标 Li 进行升序排列。输出列表必须按 x 位排序。输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …] 双向链表这道题让我联想到了上个学期OS课写的连续内存分配，当时我是用的双向链表来维护内存空间。没有采用线性表是为了更方便调试（就是懒没错），印象中室友写了个线性表就因为一个小问题花了好多时间来debug(雾。 言归正传，这道题也可以利用同样的思想来维护一段空间，我们用如下的数据结构来表示每一个独立区间（所谓独立区间就是与其相邻区间高度不同的区间）。 1234567891011121314struct Node { int height; int left; int right; Node* next; Node* pre; bool isPoint() { return left == right; } Node(int i, int j): left(i), right(j),height(0) {} Node(int i, int j, int h): left(i), right(j),height(h) {} Node(int h): left(NULL), right(NULL), height(h) {}}; 初始区间为[INT_MIN, INT_MAX]，其高度为0。之后每加入一个新的建筑，都要更新一次区间。区间更新逻辑如下 新加入建筑物的高度小于等于其覆盖到区间的高度，不产生影响。 新加入建筑物的高度大于其覆盖区间的高度，则将覆盖区间的高度更新为新建筑的高度。 由于并不是所有的区间都是恰好被新加入的建筑物覆盖的，因此我们还考虑区间的拆分问题。 对于上面的这些问题，我的思路如下 先确定新建筑物波及的区间。 对头区间和尾区间进行特殊处理（因为只有头尾区间才会面临区间拆分的可能性） 对头尾之间的其他区间进行同高度合并。 具体实现在如下代码中，关键步骤有注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187struct Node { int height; int left; int right; Node* next; Node* pre; bool isPoint() { return left == right; } Node(int i, int j): left(i), right(j),height(0) {} Node(int i, int j, int h): left(i), right(j),height(h) {} Node(int h): left(NULL), right(NULL), height(h) {}};// 在left，right间加入curvoid connect(Node* left, Node* right, Node* cur){ left-&gt;next = cur; cur-&gt;next = right; right-&gt;pre = cur; cur-&gt;pre = left;}// 删除结点curvoid deleteNode(Node*cur){ cur-&gt;pre-&gt;next = cur-&gt;next; cur-&gt;next-&gt;pre = cur-&gt;pre; delete cur;}//向左合并，直到遇到头节点或者高度不同的区间void leftMerge(Node* cur){ Node* pre = cur-&gt;pre; while(pre-&gt;height != -1 &amp;&amp; pre-&gt;height == cur-&gt;height) { cur-&gt;left = pre-&gt;left; deleteNode(pre); pre = cur-&gt;pre; }}//向右合并，直到遇到尾节点或者高度不同的区间void rightMerge(Node* cur){ Node* next = cur-&gt;next; while(next-&gt;height != -1 &amp;&amp; next-&gt;height == cur-&gt;height) { cur-&gt;right = next-&gt;right; deleteNode(next); next = cur-&gt;next; } }class Solution {public: vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) { if(buildings.empty()) return {}; Node* head = new Node(-1); Node* tail = new Node(-1); Node* tmp = new Node(INT_MIN, INT_MAX); connect(head,tail,tmp); for(auto&amp; b: buildings) { int left = b[0]; int right = b[1]; int height = b[2]; Node* cur = head-&gt;next; while(cur != tail) { if(left &gt;= cur-&gt;right) { cur = cur-&gt;next; continue; } else //找到头区间 { if(right &lt;= cur-&gt;right) // 若新加入区间正好落在头区间内 { if(height &gt; cur-&gt;height) { Node* tmp1 = new Node(left,right,height); Node* tmp2 = NULL; if(cur-&gt;right != right) tmp2 = new Node(right, cur-&gt;right,cur-&gt;height); cur-&gt;right = left; connect(cur, cur-&gt;next, tmp1); if(tmp2) connect(tmp1,tmp1-&gt;next,tmp2); if(cur-&gt;isPoint()) deleteNode(cur); leftMerge(tmp1); rightMerge(tmp1); //左右合并相同高度的区间 } } else { Node* h = cur; //头区间 Node* t = cur-&gt;next; // 确定尾区间 while(t-&gt;right &lt; right) { if(height &gt; t-&gt;height) t-&gt;height = height; t = t-&gt;next; } // 单独处理头区间 if(h-&gt;height &lt; height) { if(h-&gt;left == left) // 新建筑物左侧与头区间左侧重合 { h-&gt;height = height; leftMerge(h); } else { Node* tmp = new Node(left,h-&gt;right, height); h-&gt;right = left; connect(h,h-&gt;next,tmp); h = tmp; } } //单独处理尾区间 if(t-&gt;height &lt; height) { if(t-&gt;right == right) // 新建筑物右侧与尾区间左侧重合 { t-&gt;height= height; rightMerge(t); } else { Node* tmp = new Node(right, t-&gt;right, t-&gt;height); t-&gt;right = right; t-&gt;height = height; connect(t,t-&gt;next,tmp); } } // 合并头尾区间之间的同高度区间 Node* p = h; int temp = t-&gt;right; while(p!=tail &amp;&amp; p-&gt;right &lt;= temp) { rightMerge(p); p = p-&gt;next; } } break; } } } vector&lt;vector&lt;int&gt;&gt; res; Node* p = head-&gt;next; if(p-&gt;height != 0) // INT_MIN也被建筑物覆盖的情况 res.push_back({p-&gt;left, p-&gt;height}); p = p-&gt;next; while(p != tail) { res.push_back({p-&gt;left, p-&gt;height}); p = p-&gt;next; } // INT_MAX也被建筑物覆盖的情况 p = p-&gt;pre; if(p-&gt;height != 0 &amp;&amp; p-&gt;right == INT_MAX) res.push_back({INT_MAX,0}); return res; }}; 这个方法最坏情况的时间复杂度是$O(n^2)$（建筑物序列按左坐标升序排列且不重合）。但在通常情况下，由于建筑物重合的缘故，区间的数目会处在一个比较低的水平，对于处理实际问题来说也不失为一个好的方法。最终leetcode执行用时20ms,击败100%用户；内存消耗13.8MB，击败99.11%用户也证明了这一点。 扫描线接下来我们来换一种思路，先来考虑一下关键点生成的条件。我们知道由于建筑物重合的缘故，每一个坐标可能被多个建筑物覆盖，我们在这点上看到的天际线正是这些建筑物中最高的那一个产生的。为了便于表述我们将坐标i处的天际线高度记为h[i]。从左至右遍历每一个坐标，当h[i]改变了，关键点就产生了。 根据这个思路我们不难想到可以用堆来维护加入建筑物左右两侧的高度（对应c++中的multiset）。特别注意，为了区分左右两侧，建筑物的左侧高度用负数表示，右侧高度用正数表示。 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) { vector&lt;pair&lt;int,int&gt;&gt; new_set; multiset&lt;int&gt; height; vector&lt;vector&lt;int&gt;&gt; res; for(auto&amp; b: buildings) { new_set.push_back({b[0], -b[2]}); new_set.push_back({b[1], b[2]}); } sort(new_set.begin(), new_set.end()); height.insert(0); int pre = 0; int cur = 0; for(auto line: new_set) { if(line.second &lt; 0) height.insert(-line.second); else height.erase(height.find(line.second)); cur = *height.rbegin(); if(cur != pre) //转折点 { res.push_back({line.first, cur}); pre = cur; } } return res; }}; 线段树用线段树处理区间问题是一个好的思路。具体的实现思路如下 离散化坐标，建立新坐标和原坐标之间的映射。 延迟更新思路-当节点对应的区间落入待更新的区间中对该节点的高度进行更新，其子节点延迟更新。 123456789101112131415void update(int root, int tl, int tr, int l, int r, int height){ if(l &gt; tr || r &lt; tl) return; else if(l &lt;= tl &amp;&amp; tr &lt;= r) //节点对应的区间落入待更新的区间中 { if(height &gt; Tree[root].height) Tree[root].height = height; } else { int mid = (tl + tr) / 2; update(2*root, tl, mid, l, r, height); update(2*root+1, mid+1, tr, l, r, height); }} 关键点的导出，为了方便起见我们只考虑叶子节点。同时因为我们的更新思路是带延迟的，还要记得先对探索到的中间节点执行更新下达操作。 123456789101112131415161718void queryRes(vector&lt;vector&lt;int&gt;&gt;&amp; res, int root){ if(Tree[root].isLeaf) // 叶子节点 { if(res.empty() || res.back()[1] != Tree[root].height) //和前一个小区间高度不同，关键点出现！ res.push_back({Tree[root].left, Tree[root].height}); } else { if(Tree[root].height &gt; 0) //下达更新 { Tree[2*root].height = max(Tree[2*root].height, Tree[root].height); Tree[2*root+1].height = max(Tree[2*root+1].height, Tree[root].height); } queryRes(res, 2*root); queryRes(res, 2*root+1); }} 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class Solution {private: Node* Tree; unordered_map&lt;int, int&gt; dict1; // 实际坐标-&gt;新坐标 vector&lt;int&gt; dict2;public: void build(int root, int l, int r) { //cout &lt;&lt; root &lt;&lt; '\\t' &lt;&lt; l &lt;&lt; '\\t' &lt;&lt; r &lt;&lt; endl; //cout &lt;&lt; Tree[root].left &lt;&lt; endl; if(l &gt; r) return; else if(l == r) { Tree[root].left = dict2[l]; Tree[root].isLeaf = 1; } else { int mid = (l + r) / 2; build(root*2, l, mid); build(root*2+1,mid+1, r); } } void update(int root, int tl, int tr, int l, int r, int height) { if(l &gt; tr || r &lt; tl) return; else if(l &lt;= tl &amp;&amp; tr &lt;= r) { if(height &gt; Tree[root].height) Tree[root].height = height; } else { int mid = (tl + tr) / 2; update(2*root, tl, mid, l, r, height); update(2*root+1, mid+1, tr, l, r, height); } } void queryRes(vector&lt;vector&lt;int&gt;&gt;&amp; res, int root) { if(Tree[root].isLeaf) { if(res.empty() || res.back()[1] != Tree[root].height) res.push_back({Tree[root].left, Tree[root].height}); } else { if(Tree[root].height &gt; 0) { Tree[2*root].height = max(Tree[2*root].height, Tree[root].height); Tree[2*root+1].height = max(Tree[2*root+1].height, Tree[root].height); } queryRes(res, 2*root); queryRes(res, 2*root+1); } } vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) { if(buildings.empty()) return {}; set&lt;int&gt; st; vector&lt;vector&lt;int&gt;&gt; res; for(auto&amp; b: buildings) { st.insert(b[0]); st.insert(b[1]); } // 离散化并建立映射 int cnt = 0; for(auto iter = st.begin(); iter != st.end(); iter++) { dict2.push_back(*iter); dict1[*iter] = cnt++; } Tree = new Node[4*cnt]; build(1, 0, cnt-1); for(auto&amp; b: buildings) update(1, 0, cnt-1, dict1[b[0]], dict1[b[1]]-1, b[2]); queryRes(res, 1); return res; }};","link":"/2020/02/16/leetcode218/"},{"title":"线段树","text":"线段树线段树的结构线段树（segment tree），顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。考虑一个长度为N的数组A和一棵对应的线段树T。 树T的根节点代表整个数组A[0:N-1] 树T的每一个叶子代表数组内的每个独立元素。 树T的内部节点代表数组A的子区间A[i:j]($0 \\leq i &lt; j &lt; N$) 从根节点开始，我们依次将区间对半拆分，即可得到对应的线段树,不难看出线段树的高度为$\\log_2N$。一旦线段树建立了，它的结构就不再会变化了。它提供两个基本操作 Update：更新线段树 Query：访问一个区间并返回区间对应的属性，如最小值，最大值，总和等。 线段树可以让update和query的时间复杂度都达到$O(\\log n)$的水平。 Simple Version - to query the sumbuild123456789101112131415161718#define MAXN 1000int t[4*MAXN];void build(int a[], int v, int tl, int tr){ if(tl == tr) t[v] = a[tl]; else { int tm = (tl + tr) / 2; build(a, v*2, tl, tm); build(a, v*2+1, tm+1, tr); t[v] = t[v*2] + t[v*2+1]; }} query123456789int query(int v, int tl, int tr, int l, int r){ if(l &gt; r) return 0; if(l == tl &amp;&amp; r == tr) return t[v]; int tm = (tl + tr) / 2; return sum(v*2,t1, tm, l, min(r, tm)) + sum(v*2+1, tm+1, tr, max(l, tm+1) ,r);} update12345678910111213void update(int v, int tl, int tr, int pos, int val){ if(tl = tr) t[v] = val; else { tm = (tl + tr) / 2; if(pos &lt;= tm) update(v*2, tl, tm, pos, val); else update(v*2+1, tm+1, tr, pos, val); }} Range updates在前一个样例中，更新操作只是针对一个元素的。但事实上，在实际问题中我们也会遇到区间更新的情况，例如在给一个区间内的所有元素均加一个值。一个直接的想法是做相应次数的单点更新，当然这样一来时间复杂度就变成了$O(m\\log n)$级别，这并不是我们希望看到的。 为了解决这个问题，我们用到了一个很好的思想——延迟更新，顾名思义，延迟更新就是在更新时不进行操作，只是给它打上一个“待更新”的标签（也可能会带有一些数据），当我们用到的时候再去做更新。举一个关于求和线段树的栗子，当我们想要给区间[0,10]的子区间[0,6]内的所有元素加上val，我们会将问题拆分成[0,5]和[6,10]两部分，而[0,5]是被子区间[0,6]包含的，因此此时我们只需暂时更新对应区间[0,5]的节点即可（给这个节点加上6*val）。当然为了之后的更新，我们需要给这个节点打上一个延迟更新标记。在下一次访问到这个节点时，我们需要先将延迟的更新下达，再继续完成原定操作。 延迟更新的思路有点类似于Cache的写回法——着眼于当下，只在必要时执行操作。具体到每个问题，延迟更新都会有自己的实现方式，不要过分拘泥于常规的形式，而应该具体问题具体分析。实例可以参考leetcode218天际线","link":"/2020/02/16/线段树/"}],"tags":[{"name":"web","slug":"web","link":"/tags/web/"},{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"get","slug":"get","link":"/tags/get/"},{"name":"post","slug":"post","link":"/tags/post/"},{"name":"哈希表","slug":"哈希表","link":"/tags/哈希表/"},{"name":"子序列","slug":"子序列","link":"/tags/子序列/"},{"name":"回溯","slug":"回溯","link":"/tags/回溯/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"路径搜索","slug":"路径搜索","link":"/tags/路径搜索/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"回文串","slug":"回文串","link":"/tags/回文串/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"证明","slug":"证明","link":"/tags/证明/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"状态转移电路","slug":"状态转移电路","link":"/tags/状态转移电路/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"桶排序","slug":"桶排序","link":"/tags/桶排序/"},{"name":"基数排序","slug":"基数排序","link":"/tags/基数排序/"},{"name":"斜率","slug":"斜率","link":"/tags/斜率/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"归并","slug":"归并","link":"/tags/归并/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"域名","slug":"域名","link":"/tags/域名/"},{"name":"最优化","slug":"最优化","link":"/tags/最优化/"},{"name":"模拟退火算法","slug":"模拟退火算法","link":"/tags/模拟退火算法/"},{"name":"爬山算法","slug":"爬山算法","link":"/tags/爬山算法/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"图","slug":"图","link":"/tags/图/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/滑动窗口/"},{"name":"前缀树","slug":"前缀树","link":"/tags/前缀树/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"Manacher","slug":"Manacher","link":"/tags/Manacher/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"双向链表","slug":"双向链表","link":"/tags/双向链表/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"扫描线","slug":"扫描线","link":"/tags/扫描线/"},{"name":"堆","slug":"堆","link":"/tags/堆/"},{"name":"区间","slug":"区间","link":"/tags/区间/"}],"categories":[{"name":"文档","slug":"文档","link":"/categories/文档/"},{"name":"leetcode","slug":"文档/leetcode","link":"/categories/文档/leetcode/"},{"name":"web","slug":"文档/web","link":"/categories/文档/web/"},{"name":"博客搭建","slug":"文档/博客搭建","link":"/categories/文档/博客搭建/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"建模","slug":"文档/建模","link":"/categories/文档/建模/"},{"name":"算法与数据结构","slug":"文档/算法与数据结构","link":"/categories/文档/算法与数据结构/"}]}