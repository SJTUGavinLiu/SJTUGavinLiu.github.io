<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gavin的碎碎念~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="SJTUGavinLiu.github.io/"/>
  <updated>2020-02-06T07:46:59.440Z</updated>
  <id>SJTUGavinLiu.github.io/</id>
  
  <author>
    <name>Gavin Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode174</title>
    <link href="SJTUGavinLiu.github.io/2020/02/06/leetcode174/"/>
    <id>SJTUGavinLiu.github.io/2020/02/06/leetcode174/</id>
    <published>2020-02-06T07:46:00.000Z</published>
    <updated>2020-02-06T07:46:59.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h1><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定<strong>每次只向右或向下移动一步</strong>。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><table><thead><tr><th>-2（K）</th><th>-2</th><th>3</th></tr></thead><tbody><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5（P）</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><hr><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>​    这道题可以看作是一个路径搜索问题，因此DFS肯定是可以解决的，只需要在回溯的过程中，维护当前路径上曾达到的最低健康值，以及当前位置的健康值即可。当然，由于过于暴力，某些case超时了Orz。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>​    动态规划的核心在于状态转移方程。对于动态规划来说，当前的最优状态仅由之前的状态决定，不会受到后面发生的事件的影响。当我们正向考虑这个问题时会发现，我们无法在不知道未来信息的情况下对当前状态做出决断。这是因为，前面的状态包含两个信息：当前路径上曾达到的最低健康值（也是我们的计算目标），当前位置的健康值。假设未来的路径中均为健康回复点，那么毫无疑问我们要选择当前路径上曾达到的最低健康值大的一者。而如果未来的路经中存在健康掉落点，那么我们可能需要选择当前位置健康值大的一者，这取决于未来路径的”恶劣程度”。</p><p>​    正向的动态规划行不通，那么不妨尝试负向的策略。维护一个动态规划数组<code>dp</code>，其中<code>dp[i][j]</code>代表$(i,j)$处出发需要的最小健康值。显然<code>dp[i][j]</code>的最小值是1,可以得到状态转移方程则为<code>dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])</code>。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">int</span> height = dungeon.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> width = dungeon[<span class="hljs-number">0</span>].size();</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(height, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(width,<span class="hljs-number">0</span>));</span><br><span class="line">        dp[height<span class="hljs-number">-1</span>][width<span class="hljs-number">-1</span>] = max(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>-dungeon[height<span class="hljs-number">-1</span>][width<span class="hljs-number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = height<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">            dp[i][width<span class="hljs-number">-1</span>] = max(<span class="hljs-number">1</span>, dp[i+<span class="hljs-number">1</span>][width<span class="hljs-number">-1</span>] - dungeon[i][width<span class="hljs-number">-1</span>]);</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = width - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--)</span><br><span class="line">            dp[height<span class="hljs-number">-1</span>][j] = max(<span class="hljs-number">1</span>, dp[height<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>] - dungeon[height<span class="hljs-number">-1</span>][j]);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = height <span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = width - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = max(<span class="hljs-number">1</span>, min(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    在此基础上，可以压缩一下空间。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">int</span> height = dungeon.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> width = dungeon[<span class="hljs-number">0</span>].size();</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(width, <span class="hljs-number">0</span>);</span><br><span class="line">        dp[width<span class="hljs-number">-1</span>] = max(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>-dungeon[height<span class="hljs-number">-1</span>][width<span class="hljs-number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = width - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--)</span><br><span class="line">            dp[j] = max(<span class="hljs-number">1</span>, dp[j+<span class="hljs-number">1</span>] - dungeon[height<span class="hljs-number">-1</span>][j]);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = height <span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[width - <span class="hljs-number">1</span>] = max(<span class="hljs-number">1</span>, dp[width<span class="hljs-number">-1</span>] - dungeon[i][width<span class="hljs-number">-1</span>]); </span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = width - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = max(<span class="hljs-number">1</span>, min(dp[j+<span class="hljs-number">1</span>], dp[j]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(mn)$, 空间复杂度$O(n)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;地下城游戏&quot;&gt;&lt;a href=&quot;#地下城游戏&quot; class=&quot;headerlink&quot; title=&quot;地下城游戏&quot;&gt;&lt;/a&gt;地下城游戏&lt;/h1&gt;&lt;p&gt;一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="动态规划" scheme="SJTUGavinLiu.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode164</title>
    <link href="SJTUGavinLiu.github.io/2020/02/05/leetcode164/"/>
    <id>SJTUGavinLiu.github.io/2020/02/05/leetcode164/</id>
    <published>2020-02-05T10:47:47.000Z</published>
    <updated>2020-02-05T10:48:21.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a>最大间距</h1><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p><p>如果数组元素个数小于 2，则返回 0。</p><p>（请尝试在线性时间复杂度和空间复杂度的条件下解决此问题）</p><hr><p>常规的排序时间复杂度为$O(n \log n)$。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>针对这个问题，考虑到数的范围给定，可以采用基数排序得到一个$O(n)$的算法。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; num, <span class="hljs-keyword">int</span>&amp; <span class="hljs-built_in">exp</span>)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (num / <span class="hljs-built_in">exp</span>) % <span class="hljs-number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumGap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> Max = INT_MIN; </span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num: nums)</span><br><span class="line">            Max = max(num, Max);</span><br><span class="line">        <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp(nums.size(), <span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">while</span>(Max / <span class="hljs-built_in">exp</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                count[getIndex(num, <span class="hljs-built_in">exp</span>)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                count[i] += count[i<span class="hljs-number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.size() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[--count[getIndex(nums[i], <span class="hljs-built_in">exp</span>)]] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">                nums[i] = tmp[i];</span><br><span class="line"></span><br><span class="line">            <span class="hljs-built_in">exp</span> *= <span class="hljs-number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size() - <span class="hljs-number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = max(res, nums[i+<span class="hljs-number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的关键在于如何设置一个合理桶大小，最糟糕的情况是每个元素一个桶，这在元素之间大小差异过大时，无论是时间还是空间的开销都是过于昂贵的</p><p>假设有一个含$N$个元素的数组，最大值是$Max$,最小值是$Min$。那么其最大间距的最小值应该为$\lfloor \frac{(Max - Min)}{(N-1)}\rfloor + 1$（均匀分散的时候取到）。这就启发我们及那个桶的大小设置成$\lfloor \frac{(Max - Min)}{(N-1)}\rfloor + 1$。如此一来，我们的关注重点只需放在临近的桶上而不需要考虑桶内间距（这是因为桶内间距小于最大间距的最小值，没有参考价值）。</p><p>具体来说，可以给每个桶设置一个最大值，和最小值。每一次的比较只需要在上一个桶的最大值与当前桶的最小值之间进行（没有元素的桶跳过）。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> Max, Min;</span><br><span class="line">    <span class="hljs-keyword">int</span> bucketNum;</span><br><span class="line">    <span class="hljs-keyword">int</span> bucketSize;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; num)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (num - Min) / bucketSize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumGap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        Max = INT_MIN;</span><br><span class="line">        Min = INT_MAX;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num: nums)</span><br><span class="line">        &#123;</span><br><span class="line">            Max = max(Max, num);</span><br><span class="line">            Min = min(Min, num);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> Max-Min;</span><br><span class="line">        bucketSize = (Max - Min) / (nums.size() - <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;</span><br><span class="line">        bucketNum = (Max - Min) / bucketSize;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//cout &lt;&lt; bucketSize &lt;&lt; ' ' &lt;&lt; bucketNum;</span></span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; bucketMax(bucketNum+<span class="hljs-number">1</span>, INT_MIN);</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; bucketMin(bucketNum+<span class="hljs-number">1</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num: nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> idx = getIndex(num);</span><br><span class="line">            bucketMax[idx] = max(bucketMax[idx], num);</span><br><span class="line">            bucketMin[idx] = min(bucketMin[idx] ,num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> pre = INT_MAX;</span><br><span class="line">        <span class="hljs-keyword">int</span> gap = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= bucketNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(bucketMax[i] == INT_MIN) <span class="hljs-keyword">continue</span>;</span><br><span class="line">            gap = max(gap, bucketMin[i] - pre);</span><br><span class="line">            pre = bucketMax[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> gap;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最大间距&quot;&gt;&lt;a href=&quot;#最大间距&quot; class=&quot;headerlink&quot; title=&quot;最大间距&quot;&gt;&lt;/a&gt;最大间距&lt;/h1&gt;&lt;p&gt;给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。&lt;/p&gt;
&lt;p&gt;如果数组元素个数小于 2，则返回 0。&lt;/p
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="排序" scheme="SJTUGavinLiu.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="桶排序" scheme="SJTUGavinLiu.github.io/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="SJTUGavinLiu.github.io/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode152</title>
    <link href="SJTUGavinLiu.github.io/2020/02/04/leetcode152/"/>
    <id>SJTUGavinLiu.github.io/2020/02/04/leetcode152/</id>
    <published>2020-02-04T08:58:16.000Z</published>
    <updated>2020-02-04T08:59:19.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="乘积最大子序列"><a href="#乘积最大子序列" class="headerlink" title="乘积最大子序列"></a>乘积最大子序列</h1><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><hr><p>注意到三个事实。</p><ol><li><p>含0的序列，$\min \max_\limits{i,j} \mathop{mul}(l_{ij}) = 0$ 。($l_{ij}$指子序列<code>nums[i,j]</code>) </p></li><li><p>经过0的子序列乘积为0</p></li><li><p>不含0且至少有一个正数的序列的最大乘积子序列里含偶数个负数。</p></li></ol><p>考虑到FACT 2，我们将序列拆分成不含0的子列分别考虑。</p><ul><li><p>如果子列含有的负数个数为偶数，其子序列乘积最大值就是其本身乘积最大值。</p></li><li><p>如果子列含有的负数个数为奇数，如下所示</p><p>${…,a_1,…….., a_{2k+1},…}$，（${a_n}$ 为负数数列）</p><p>其子序列乘积最大值为序列${…,a_1,…,a_{2k+1}} / {a_{2k+1}}$与序列${a_1,…,a_{2k+1},…} / {a_{1}}$二者中的乘积较大者。这是因为</p><ol><li>子序列长度增加，乘积单调不减。</li><li>不含0且至少有一个正数的序列的最大乘积子序列里含偶数个负数。</li></ol><p>针对这种情况，我们可以左右遍历，分别计算累积的最大乘积，取较大值即可。</p></li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span>(i &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">while</span>(i &lt; nums.size() &amp;&amp; nums[i] == <span class="hljs-number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="hljs-keyword">int</span> j = i;    </span><br><span class="line">            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span>(j &lt; nums.size() &amp;&amp; nums[j] != <span class="hljs-number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt *= nums[j];</span><br><span class="line">                res = max(res, cnt);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span>(j &lt; nums.size())</span><br><span class="line">                res = max(res, <span class="hljs-number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">int</span> tmp = i;</span><br><span class="line">            i = j;</span><br><span class="line">            j--;</span><br><span class="line">            cnt = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span>(j &gt;= tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt *= nums[j];</span><br><span class="line">                res = max(res, cnt);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;乘积最大子序列&quot;&gt;&lt;a href=&quot;#乘积最大子序列&quot; class=&quot;headerlink&quot; title=&quot;乘积最大子序列&quot;&gt;&lt;/a&gt;乘积最大子序列&lt;/h1&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出一个序列中乘积最大的连续子序列（该序列至
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="子序列" scheme="SJTUGavinLiu.github.io/tags/%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode149</title>
    <link href="SJTUGavinLiu.github.io/2020/02/03/leetcode149/"/>
    <id>SJTUGavinLiu.github.io/2020/02/03/leetcode149/</id>
    <published>2020-02-03T14:28:44.000Z</published>
    <updated>2020-02-03T14:34:27.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支线上最多的点数"><a href="#支线上最多的点数" class="headerlink" title="支线上最多的点数"></a>支线上最多的点数</h1><p>给定一个二维平面，平面上有 <em>n</em> 个点，求最多有多少个点在同一条直线上。</p><hr><p>从一个基点出发，遍历其他的点（$O(n^2)$），分别计算</p><ul><li>与基点重合点的数量（<code>same</code>）</li><li>经过基点不同斜率的直线上的点数（<code>dict[slope]</code>）</li></ul><p>取第一项的值与第二项中的最大值（<code>max_count</code>）之和为基点对应极大值，在遍历过程中更新结果。</p><p>我们的遍历是建立在确定的基点上的，因此只需斜率就可以唯一确定一条直线。考虑到浮点数的精度问题，我转而考虑用辗转相除法将<code>dx,dy</code>约化为最简形式并以<code>pair</code>的形式存储。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-comment">// x &lt; y</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span> ? y : gcd(y % x, x);</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; getSlope(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> dx = x1 - x2;</span><br><span class="line">        <span class="hljs-keyword">int</span> dy = y1 - y2;</span><br><span class="line">        <span class="hljs-keyword">if</span>(dy == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;y1, <span class="hljs-number">0</span>&#125;;</span><br><span class="line">        <span class="hljs-keyword">if</span>(dx == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, x1&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> d = gcd(dx, dy);</span><br><span class="line">        <span class="hljs-keyword">return</span> &#123;dy / d, dx / d&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(points.size() &lt; <span class="hljs-number">3</span>)   <span class="hljs-keyword">return</span> points.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> len = points.size();</span><br><span class="line">        <span class="hljs-comment">//int same = 0;</span></span><br><span class="line">        <span class="hljs-keyword">int</span> res = <span class="hljs-number">2</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> same = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">int</span> max_count = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-built_in">map</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">int</span>&gt; dict;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(points[j][<span class="hljs-number">0</span>] == points[i][<span class="hljs-number">0</span>] &amp;&amp; points[j][<span class="hljs-number">1</span>] == points[i][<span class="hljs-number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    same++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; slope = getSlope(points[i][<span class="hljs-number">0</span>], points[i][<span class="hljs-number">1</span>], points[j][<span class="hljs-number">0</span>], points[j][<span class="hljs-number">1</span>]);</span><br><span class="line">                    <span class="hljs-keyword">if</span>(!dict.count(slope))</span><br><span class="line">                        dict[slope] = <span class="hljs-number">1</span>;</span><br><span class="line">                    <span class="hljs-keyword">else</span></span><br><span class="line">                        dict[slope]++;</span><br><span class="line">                    max_count = max(max_count, dict[slope]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, same + max_count);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;支线上最多的点数&quot;&gt;&lt;a href=&quot;#支线上最多的点数&quot; class=&quot;headerlink&quot; title=&quot;支线上最多的点数&quot;&gt;&lt;/a&gt;支线上最多的点数&lt;/h1&gt;&lt;p&gt;给定一个二维平面，平面上有 &lt;em&gt;n&lt;/em&gt; 个点，求最多有多少个点在同一条直线上。&lt;/
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="斜率" scheme="SJTUGavinLiu.github.io/tags/%E6%96%9C%E7%8E%87/"/>
    
      <category term="哈希表" scheme="SJTUGavinLiu.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode148</title>
    <link href="SJTUGavinLiu.github.io/2020/02/03/leetcode148/"/>
    <id>SJTUGavinLiu.github.io/2020/02/03/leetcode148/</id>
    <published>2020-02-03T14:26:36.000Z</published>
    <updated>2020-02-03T14:30:25.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h1><p>在 $O(n \log n)$ 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><hr><p>注意到常数空间复杂度，递归的算法就可以先排除掉了。</p><p>一个简单的想法是自下而上地归并，函数<code>cut(head, step)</code>从头部截取<code>step</code>长度的子列表并返回下一段列表的起始节点。<code>merge</code>合并两个列表并返回尾部节点。</p><p><img src="/images/leetcode148.assets/1580708996056.png" alt="1580708996056"></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="hljs-comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="hljs-comment"> *     int val;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode *next;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="hljs-comment"> * &#125;;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>: </span><br><span class="line">    <span class="hljs-function">ListNode* <span class="hljs-title">cut</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> step)</span> <span class="hljs-comment">// divide a sublist with length 'step' off the list</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!head)   <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; step<span class="hljs-number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            step--;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* r, ListNode* list1, ListNode* list2)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        ListNode* p = list1;</span><br><span class="line">        ListNode* q = list2;</span><br><span class="line">        <span class="hljs-keyword">while</span>(p || q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(!q)</span><br><span class="line">            &#123;</span><br><span class="line">                r-&gt;next = p;</span><br><span class="line">                <span class="hljs-keyword">while</span>(p-&gt;next)</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                <span class="hljs-keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!p)</span><br><span class="line">            &#123;</span><br><span class="line">                r-&gt;next = q;</span><br><span class="line">                <span class="hljs-keyword">while</span>(q-&gt;next)</span><br><span class="line">                    q = q-&gt;next;</span><br><span class="line">                <span class="hljs-keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span>(p-&gt;val &gt; q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                r-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            r-&gt;next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!head)   <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line">        ListNode* dum = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);</span><br><span class="line">        dum-&gt;next = head;</span><br><span class="line">        <span class="hljs-keyword">int</span> step = <span class="hljs-number">1</span>;</span><br><span class="line">        ListNode* pre = dum;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = dum;</span><br><span class="line">            cur = dum-&gt;next;</span><br><span class="line">            cnt = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* first = cur;</span><br><span class="line">                ListNode* second = cut(cur, step);</span><br><span class="line">                cur = cut(second, step);</span><br><span class="line">                pre = merge(pre, first, second);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)    <span class="hljs-keyword">break</span>;</span><br><span class="line">            step *= <span class="hljs-number">2</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序链表&quot;&gt;&lt;a href=&quot;#排序链表&quot; class=&quot;headerlink&quot; title=&quot;排序链表&quot;&gt;&lt;/a&gt;排序链表&lt;/h1&gt;&lt;p&gt;在 $O(n \log n)$ 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;注意到常数空间复杂
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="链表" scheme="SJTUGavinLiu.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="归并" scheme="SJTUGavinLiu.github.io/tags/%E5%BD%92%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode137</title>
    <link href="SJTUGavinLiu.github.io/2020/01/31/leetcode137/"/>
    <id>SJTUGavinLiu.github.io/2020/01/31/leetcode137/</id>
    <published>2020-01-31T03:12:01.000Z</published>
    <updated>2020-01-31T03:15:14.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只出现一次数字Ⅱ"><a href="#只出现一次数字Ⅱ" class="headerlink" title="只出现一次数字Ⅱ"></a>只出现一次数字Ⅱ</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><hr><p>设计一个状态转移电路使得三次转换后能回到原始状态<code>00-&gt;01-&gt;10-&gt;00</code>。</p><p>先整一个状态转移矩阵</p><table><thead><tr><th>a</th><th>b</th><th>x</th><th>new_a</th><th>new_b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>画b的卡诺图</p><table><thead><tr><th>x\ab</th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>X</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>X</td><td>0</td></tr></tbody></table><p>b = (b ^ x) &amp; ~a</p><p>画a的卡诺图</p><table><thead><tr><th>x\ab</th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>X</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>X</td><td>1</td></tr></tbody></table><p> a = (x &amp; b) | (~x &amp; a)</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> tmp;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;</span><br><span class="line">            tmp = b;</span><br><span class="line">            b = (b ^ x) &amp; ~a;</span><br><span class="line">            a = (x &amp; tmp) | (~x &amp; a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于代码的实现中，每一位的计算并不是并行进行的，所以可以通过画一个行列由a,new_b,x构成的卡诺图来利用先生成的位。</p><table><thead><tr><th>x\a new_b</th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>X</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>X</td><td>1</td></tr></tbody></table><p>a = (x ^ a) &amp; ~ new_b</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;</span><br><span class="line">        b = (b ^ x) &amp; ~a;</span><br><span class="line">        a = (a ^ x) &amp; ~b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;只出现一次数字Ⅱ&quot;&gt;&lt;a href=&quot;#只出现一次数字Ⅱ&quot; class=&quot;headerlink&quot; title=&quot;只出现一次数字Ⅱ&quot;&gt;&lt;/a&gt;只出现一次数字Ⅱ&lt;/h1&gt;&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="状态转移电路" scheme="SJTUGavinLiu.github.io/tags/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E7%94%B5%E8%B7%AF/"/>
    
      <category term="位运算" scheme="SJTUGavinLiu.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode135</title>
    <link href="SJTUGavinLiu.github.io/2020/01/30/leetcode135/"/>
    <id>SJTUGavinLiu.github.io/2020/01/30/leetcode135/</id>
    <published>2020-01-30T08:49:25.000Z</published>
    <updated>2020-02-03T14:33:34.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h1><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li><p>每个孩子至少分配到 1 个糖果。</p></li><li><p>相邻的孩子中，评分高的孩子必须获得更多的糖果。</p></li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><hr><ul><li><p>思路一</p><p>看到这道题就开始脑补一段分数变化的折线图。显然我们特别需要关注的是折线图的高峰和低谷，最理想的情况是每一个低谷的位置都是一颗糖果（如果一位同学夹在俩大佬之间真是有够惨的233） ，高峰处根据左右两侧的上升，选择较大的一者。根据这一思路，可以从左右两次遍历数组，每次给上升的一面赋值（包括峰值点）。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(ratings.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = ratings.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; candies(len, <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">bool</span> up = <span class="hljs-number">0</span>;    <span class="hljs-comment">// Status: up</span></span><br><span class="line">        <span class="hljs-comment">//int pos = 0;    //postition of base</span></span><br><span class="line">        <span class="hljs-comment">//up = ratings[1] &gt; ratings[0];</span></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; len - <span class="hljs-number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i+<span class="hljs-number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(!up)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="hljs-comment">// reset base</span></span><br><span class="line">                    up = <span class="hljs-number">1</span>;</span><br><span class="line">                    candies[i] = <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                candies[i+<span class="hljs-number">1</span>] = candies[i] + <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] == ratings[i+<span class="hljs-number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(up)  candies[i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(up)  up = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//up = ratings[len-1] &lt; ratings[len-2];</span></span><br><span class="line">        up = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i<span class="hljs-number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(!up)</span><br><span class="line">                &#123;</span><br><span class="line">                    candies[i] = <span class="hljs-number">1</span>;</span><br><span class="line">                    up = <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span>(candies[i<span class="hljs-number">-1</span>] &lt; candies[i] + <span class="hljs-number">1</span>)</span><br><span class="line">                    candies[i<span class="hljs-number">-1</span>] = candies[i] + <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i<span class="hljs-number">-1</span>] == ratings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(up &amp;&amp; candies[i<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">1</span>)</span><br><span class="line">                    candies[i<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(up)  up = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += candies[<span class="hljs-number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路二</p><p>事实上，当<code>candies</code>数组已经被初始化为1时，我根本无需去对相等的情况进行特别的考虑，所以<code>up</code>这个变量就不再必要了。精简一下代码可以得到。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(ratings.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = ratings.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; candies(len, <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i+<span class="hljs-number">1</span>])</span><br><span class="line">                candies[i+<span class="hljs-number">1</span>] = candies[i] + <span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i<span class="hljs-number">-1</span>])</span><br><span class="line">                candies[i<span class="hljs-number">-1</span>] = max(candies[i] + <span class="hljs-number">1</span>, candies[i<span class="hljs-number">-1</span>]);</span><br><span class="line">            sum += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += candies[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路三</p><p>思路三来自官方题解Orz。这个算法只需要用到常数的空间，思路本身并不难想到——通过考虑每一座山（一个峰）的上升次数和下降次数计算其消耗的最小糖果量。问题的关键在于如何细分每一次山的结束。</p><ol><li>之前一次的状态下降，当前状态上升：当前的山结束，将谷底计入下一座山中</li><li>之前一次的状态下降，当前状态平行：由于两个相同分数的小孩之间没有糖果数量限制，事实上这时候也相当于来到一个谷底了，当前山结束。</li><li>之前一次的状态上升，当前状态下降：此时山开始步入下行，继续发展。</li><li>之前一次的状态上升，当前状态平行：类似情况2，相当于进入谷底，当前山结束。</li></ol><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n )</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> n*(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(ratings.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = ratings.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> up = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> down = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>] &gt; ratings[i])   cur = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>] &lt; ratings[i])  cur = <span class="hljs-number">-1</span>;</span><br><span class="line">            <span class="hljs-keyword">else</span>    cur = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>((last == <span class="hljs-number">-1</span> &amp;&amp; cur &gt;= <span class="hljs-number">0</span>) || (last == <span class="hljs-number">1</span> &amp;&amp; cur == <span class="hljs-number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum + cal(up) + cal(down) + max(up,down);</span><br><span class="line">                up = <span class="hljs-number">0</span>;</span><br><span class="line">                down = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)</span><br><span class="line">                up++;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">-1</span>)</span><br><span class="line">                down++;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                sum++;</span><br><span class="line">            last = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum + cal(up) + cal(down) + max(up,down) + <span class="hljs-number">1</span>; <span class="hljs-comment">//补上最后一个点的基数</span></span><br><span class="line">        <span class="hljs-keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分发糖果&quot;&gt;&lt;a href=&quot;#分发糖果&quot; class=&quot;headerlink&quot; title=&quot;分发糖果&quot;&gt;&lt;/a&gt;分发糖果&lt;/h1&gt;&lt;p&gt;老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。&lt;/p&gt;
&lt;p&gt;你需要按照以
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="贪心" scheme="SJTUGavinLiu.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>leetcode132</title>
    <link href="SJTUGavinLiu.github.io/2020/01/30/leetcode132/"/>
    <id>SJTUGavinLiu.github.io/2020/01/30/leetcode132/</id>
    <published>2020-01-30T02:31:56.000Z</published>
    <updated>2020-02-06T07:47:49.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分割回文串Ⅱ"><a href="#分割回文串Ⅱ" class="headerlink" title="分割回文串Ⅱ"></a>分割回文串Ⅱ</h1><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p><p>返回符合要求的最少分割次数。</p><hr><ul><li><p>思路一</p><p>设置动态规划数组<code>dp</code>,<code>dp[i]</code>代表<code>s[:i-1]</code>的minCut。这个做法确实太暴力了，回文串的判定过程中产生了大量冗余计算，例如在判定“abcba”的过程中，事实上我们也知道了“bcb”是回文串。但在这个算法中这些信息并没有得到利用。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalin</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> right = s.size() - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(s[left] != s[right])</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s.empty())   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = s.size();</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(len+<span class="hljs-number">1</span>,INT_MAX);</span><br><span class="line">        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = j; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(isPalin(s.substr(i,j-i+<span class="hljs-number">1</span>)))</span><br><span class="line">                    dp[j+<span class="hljs-number">1</span>] = min(dp[j+<span class="hljs-number">1</span>],<span class="hljs-number">1</span>+dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路二</p><p>一个简单的思路的方法是通过$O(n^2)$中心扩散算法先计算出所有字串中的回文串以此简化计算量。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> len;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SearchPalin</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp;s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; isPalin, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; len &amp;&amp; s[i] == s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            isPalin[i][j] = <span class="hljs-number">1</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s.empty())   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        len = s.size();</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; isPalin(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(len,<span class="hljs-number">0</span>));</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            SearchPalin(s, isPalin, i, i);</span><br><span class="line">            SearchPalin(s, isPalin, i, i+<span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(len+<span class="hljs-number">1</span>,INT_MAX);</span><br><span class="line">        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = j; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(isPalin[i][j])</span><br><span class="line">                    dp[j+<span class="hljs-number">1</span>] = min(dp[j+<span class="hljs-number">1</span>],<span class="hljs-number">1</span>+dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[len];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路三</p><p>思路二中的方法需要用到$O(n^2)$的空间，事实上我们也可以用$O(1)$的空间实现同样的效果。（然而Leetcode给的内存消耗比思路二高了好多（大雾</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> len;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; dp)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span>)</span><br><span class="line">                dp[right] = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                dp[right] = min (dp[right], dp[left<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>); </span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s.empty())   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        len = s.size();</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(len,INT_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            helper(s,i,i,dp);</span><br><span class="line">            helper(s,i,i+<span class="hljs-number">1</span>,dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分割回文串Ⅱ&quot;&gt;&lt;a href=&quot;#分割回文串Ⅱ&quot; class=&quot;headerlink&quot; title=&quot;分割回文串Ⅱ&quot;&gt;&lt;/a&gt;分割回文串Ⅱ&lt;/h1&gt;&lt;p&gt;给定一个字符串 &lt;em&gt;s&lt;/em&gt;，将 &lt;em&gt;s&lt;/em&gt; 分割成一些子串，使每个子串都是回文串。&lt;/p
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="回文串" scheme="SJTUGavinLiu.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="SJTUGavinLiu.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode128</title>
    <link href="SJTUGavinLiu.github.io/2020/01/29/leetcode128/"/>
    <id>SJTUGavinLiu.github.io/2020/01/29/leetcode128/</id>
    <published>2020-01-29T06:23:41.000Z</published>
    <updated>2020-02-03T14:34:20.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h1><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 <em>O(n)</em>。</p><hr><p>最直接的想法是排序加遍历，但是不符合时间复杂度线性的要求。</p><ul><li><p>思路</p><p>直观上，我们希望在一遍扫描数组的过程中，对每一个数做如下操作</p><ol><li>和已有的序列结合形成新序列</li><li>自己独立生成一个序列</li></ol><p>为了实现这一想法，我用HashMap来存储每一个数所处序列的长度。对于遍历到的每一个数，我们都根据其左右两个数的序列长度来计算总长度，并对两个端点进行更新。我们可以注意到，此时除了端点，序列内其他点在HashMap中的长度并不是其所处序列的长度。这一点是可以接受的，因为我们每次考虑的都是新加入HashMap的数，不可能存在落入已有序列的可能性。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(nums.empty())    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; dict;</span><br><span class="line">        <span class="hljs-keyword">int</span> left, right, curLen;</span><br><span class="line">        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num: nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(!dict.count(num))</span><br><span class="line">            &#123;</span><br><span class="line">                left = dict.count(num<span class="hljs-number">-1</span>) ? dict[num<span class="hljs-number">-1</span>] : <span class="hljs-number">0</span>;</span><br><span class="line">                right = dict.count(num+<span class="hljs-number">1</span>) ? dict[num+<span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;</span><br><span class="line">                </span><br><span class="line">                curLen = left + right + <span class="hljs-number">1</span>;</span><br><span class="line">                maxLen = maxLen &gt; curLen ? maxLen : curLen;</span><br><span class="line"></span><br><span class="line">                dict[num] = curLen; <span class="hljs-comment">// take the place</span></span><br><span class="line">                dict[num - left] = curLen;</span><br><span class="line">                dict[num + right] = curLen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> maxLen;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最长连续序列&quot;&gt;&lt;a href=&quot;#最长连续序列&quot; class=&quot;headerlink&quot; title=&quot;最长连续序列&quot;&gt;&lt;/a&gt;最长连续序列&lt;/h1&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;要求算法的时间复杂度为 &lt;em&gt;O(n)&lt;
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="哈希表" scheme="SJTUGavinLiu.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="子序列" scheme="SJTUGavinLiu.github.io/tags/%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode126</title>
    <link href="SJTUGavinLiu.github.io/2020/01/29/leetcode126/"/>
    <id>SJTUGavinLiu.github.io/2020/01/29/leetcode126/</id>
    <published>2020-01-29T02:47:42.000Z</published>
    <updated>2020-02-03T14:34:19.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单词接龙Ⅱ"><a href="#单词接龙Ⅱ" class="headerlink" title="单词接龙Ⅱ"></a>单词接龙Ⅱ</h1><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><ol><li><p>每次转换只能改变一个字母。</p></li><li><p>转换过程中的中间单词必须是字典中的单词。<br>说明:</p></li></ol><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><hr><p>题目的思路是比较明晰的，先通过BFS找到最短路径，再backtrack出所有路径即可。</p><ul><li><p>思路一</p><p>BFS的过程中记录下每层的单词，这样利用这个信息进行回溯。这个思路在碰到长WordList就行不通了，原因在于每层的单词数量过多，导致回溯的开销爆炸-.-</p></li><li><p>思路二</p><p>存储每层的单词显然行不通了，于是就想到了通过在BFS的过程中建立一个记录层次间连接的邻接表（Adjacent List）来加速回溯的过程。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> wordLen;</span><br><span class="line">    <span class="hljs-built_in">string</span> end;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAjac</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 0: not ajacent or same</span></span><br><span class="line">        <span class="hljs-comment">// 1: ajacent</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(flag &amp;&amp; a[i] != b[i])    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span>(a[i] != b[i])    flag = <span class="hljs-number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">string</span> cur, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; &amp;res, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; &amp;tmp, <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; nextStep)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(isAjac(cur,end))</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(end);</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> word: nextStep[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(word);</span><br><span class="line">                backtrack(word, res, tmp, nextStep);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; findLadders(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; s(wordList.begin(), wordList.end());</span><br><span class="line">        <span class="hljs-keyword">if</span>(!s.count(endWord))   <span class="hljs-keyword">return</span> res;</span><br><span class="line">        wordLen = beginWord.size();</span><br><span class="line">        end = endWord;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; p&#123;beginWord&#125;;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; q;</span><br><span class="line">        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; nextStep; <span class="hljs-comment">// To store words that can be reached from the given word.</span></span><br><span class="line">        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// when the path has been found, flag = 1</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(!p.empty() &amp;&amp; !flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter1 = p.begin(); iter1 != p.end(); iter1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter2 = s.begin(); iter2 != s.end(); iter2++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span>(isAjac(*iter1, *iter2))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="hljs-keyword">if</span>(*iter2 == endWord)</span><br><span class="line">                            flag = <span class="hljs-number">1</span>;</span><br><span class="line">                        nextStep[*iter1].push_back(*iter2);</span><br><span class="line">                        q.insert(*iter2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = q.begin(); iter != q.end(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                s.erase(*iter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(p,q);</span><br><span class="line">            q.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; tmp(<span class="hljs-number">1</span>, beginWord);</span><br><span class="line">        <span class="hljs-keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(beginWord, res, tmp, nextStep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路三</p><p>可以通过双向BFS进一步提升算法效率</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> wordLen;</span><br><span class="line">    <span class="hljs-built_in">string</span> end;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAjac</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 0: not ajacent or same</span></span><br><span class="line">        <span class="hljs-comment">// 1: ajacent</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(flag &amp;&amp; a[i] != b[i])    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span>(a[i] != b[i])    flag = <span class="hljs-number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; cur, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; res, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; tmp, <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; nextStep)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(isAjac(cur,end))</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(end);</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> word: nextStep[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(word);</span><br><span class="line">                backtrack(word, res, tmp, nextStep);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; findLadders(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; s(wordList.begin(), wordList.end());</span><br><span class="line">        <span class="hljs-keyword">if</span>(!s.count(endWord))   <span class="hljs-keyword">return</span> res;</span><br><span class="line">        wordLen = beginWord.size();</span><br><span class="line">        end = endWord;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; p&#123;beginWord&#125;;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; q;</span><br><span class="line">        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; nextStep; <span class="hljs-comment">// To store words that can be reached from the given word.</span></span><br><span class="line">        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// when the path has been found, flag = 1</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(!p.empty() &amp;&amp; !flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = p.begin(); iter != p.end(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-built_in">string</span> str = *iter;</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="hljs-keyword">char</span> c = str[i];</span><br><span class="line">                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> j = <span class="hljs-string">'a'</span>; j &lt;= <span class="hljs-string">'z'</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        str[i] = j;</span><br><span class="line">                        <span class="hljs-keyword">if</span>(str == endWord)</span><br><span class="line">                            flag = <span class="hljs-number">1</span>;</span><br><span class="line">                        <span class="hljs-keyword">if</span>(s.count(str))</span><br><span class="line">                        &#123;</span><br><span class="line">                            nextStep[*iter].push_back(str);</span><br><span class="line">                            q.insert(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    str[i] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = q.begin(); iter != q.end(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                s.erase(*iter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(p,q);</span><br><span class="line">            q.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; tmp(<span class="hljs-number">1</span>, beginWord);</span><br><span class="line">            backtrack(beginWord, res, tmp, nextStep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">    Solution 3</span></span><br><span class="line"><span class="hljs-comment">    Bidirectional BFS</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> __ = []() &#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="hljs-literal">false</span>);</span><br><span class="line">  <span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">nullptr</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> wordLen;</span><br><span class="line">    <span class="hljs-built_in">string</span> end;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAjac</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; a, <span class="hljs-built_in">string</span>&amp; b)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 0: not ajacent or same</span></span><br><span class="line">        <span class="hljs-comment">// 1: ajacent</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(flag &amp;&amp; a[i] != b[i])    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span>(a[i] != b[i])    flag = <span class="hljs-number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; cur, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; res, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; tmp, <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; nextStep)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(isAjac(cur,end))</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(end);</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; word: nextStep[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(word);</span><br><span class="line">                backtrack(word, res, tmp, nextStep);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; findLadders(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; s(wordList.begin(), wordList.end());</span><br><span class="line">        <span class="hljs-keyword">if</span>(!s.count(endWord))   <span class="hljs-keyword">return</span> res;</span><br><span class="line">        wordLen = beginWord.size();</span><br><span class="line">        end = endWord;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; p1&#123;beginWord&#125;;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; p2&#123;endWord&#125;;</span><br><span class="line">        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; q;</span><br><span class="line">        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; nextStep; <span class="hljs-comment">// To store words that can be reached from the given word.</span></span><br><span class="line">        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// when the path has been found, flag = 1</span></span><br><span class="line">        <span class="hljs-keyword">bool</span> back = <span class="hljs-number">0</span>;  <span class="hljs-comment">// when the direction of BFS is backward, back = 1</span></span><br><span class="line">        s.erase(endWord);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span>(!p1.empty() &amp;&amp; !p2.empty() &amp;&amp; !flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(p1.size() &gt; p2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                swap(p1,p2);</span><br><span class="line">                back = !back;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; w : p1)</span><br><span class="line">                s.erase(w);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; w : p2)</span><br><span class="line">                s.erase(w);</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = p1.begin(); iter != p1.end(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-built_in">string</span> str = *iter;</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="hljs-keyword">char</span> c = str[i];</span><br><span class="line">                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> j = <span class="hljs-string">'a'</span>; j &lt;= <span class="hljs-string">'z'</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        str[i] = j;</span><br><span class="line">                        <span class="hljs-keyword">if</span>(p2.count(str))</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag = <span class="hljs-number">1</span>;</span><br><span class="line">                            <span class="hljs-keyword">if</span>(back)</span><br><span class="line">                                nextStep[str].push_back(*iter);</span><br><span class="line">                            <span class="hljs-keyword">else</span></span><br><span class="line">                                nextStep[*iter].push_back(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="hljs-keyword">if</span>(s.count(str))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="hljs-keyword">if</span>(back)</span><br><span class="line">                                nextStep[str].push_back(*iter);</span><br><span class="line">                            <span class="hljs-keyword">else</span></span><br><span class="line">                                nextStep[*iter].push_back(str);</span><br><span class="line">                            q.insert(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    str[i] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(p1,q);</span><br><span class="line">            q.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; tmp(<span class="hljs-number">1</span>, beginWord);</span><br><span class="line">            backtrack(beginWord, res, tmp, nextStep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单词接龙Ⅱ&quot;&gt;&lt;a href=&quot;#单词接龙Ⅱ&quot; class=&quot;headerlink&quot; title=&quot;单词接龙Ⅱ&quot;&gt;&lt;/a&gt;单词接龙Ⅱ&lt;/h1&gt;&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="leetcode" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/leetcode/"/>
    
    
      <category term="BFS" scheme="SJTUGavinLiu.github.io/tags/BFS/"/>
    
      <category term="回溯" scheme="SJTUGavinLiu.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="哈希表" scheme="SJTUGavinLiu.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="路径搜索" scheme="SJTUGavinLiu.github.io/tags/%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>GET&amp;POST&amp;AJAX</title>
    <link href="SJTUGavinLiu.github.io/2020/01/28/GET&amp;POST&amp;AJAX/"/>
    <id>SJTUGavinLiu.github.io/2020/01/28/GET&amp;POST&amp;AJAX/</id>
    <published>2020-01-28T15:46:44.000Z</published>
    <updated>2020-01-28T15:47:56.140Z</updated>
    
    <content type="html"><![CDATA[<p>最近整了点web相关的工作，借此整理了一下HTTP请求相关的内容。</p><h2 id="HTTP-Hyper-Text-Transfer-Protocol"><a href="#HTTP-Hyper-Text-Transfer-Protocol" class="headerlink" title="HTTP (Hyper Text Transfer Protocol)"></a>HTTP (Hyper Text Transfer Protocol)</h2><p>HTTP-超文本传输协议工作于Server-Client架构上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 而GET和POST则是HTTP最常用的两个方法。</p><h2 id="GET-amp-POST"><a href="#GET-amp-POST" class="headerlink" title="GET &amp; POST"></a>GET &amp; POST</h2><p>先搬运一段维基百科上的定义</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p><strong>GET</strong> requests a representation of the specified resource. Note that GET should <strong>NOT</strong> be used for operations that cause side-effects, such as using it for taking actions in web applications. One reason for this is that GET may be used arbitrarily by robots or crawlers, which should not need to consider the side effects that a request should cause.</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p><strong>POST</strong> submits data to be processed (e.g., from an HTML form) to the identified resource. The data is included in the body of the request. This may result in the creation of a new resource or the updates of existing resources or both.</p><p>由此可以看出，GET代表一个幂等（Idempotent）的读取操作，而POST则代表一个不幂等的更新操作。</p><p>所谓幂等，即任意多次执行所产生的影响均与依次执行的影响相同。</p><h3 id="JQuery-AJAX-get-amp-post"><a href="#JQuery-AJAX-get-amp-post" class="headerlink" title="JQuery AJAX get() &amp; post()"></a>JQuery AJAX get() &amp; post()</h3><p>AJAX - Asynchronous Javascript And XML</p><p>无需重新加载整个网页更新部分网页的技术</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* get */</span></span><br><span class="line">$.<span class="hljs-keyword">get</span>(URL,callback);</span><br><span class="line">/* example */</span><br><span class="line">$.<span class="hljs-keyword">get</span>('http://127.0.0.1:5000/data',function(data,status)&#123;</span><br><span class="line">   <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* post */</span></span><br><span class="line">$.post(URL,data,callback)</span><br><span class="line"><span class="hljs-comment">/* example */</span></span><br><span class="line">$.post(<span class="hljs-string">'http://127.0.0.1:5000/data'</span>,</span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="hljs-string">'gavin'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data,status</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* ajax template example */</span></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="hljs-string">'get'</span>,</span><br><span class="line">    url: <span class="hljs-string">'http://127.0.0.1:5000/demo/data'</span>,</span><br><span class="line">    dataType: <span class="hljs-string">"jsonp"</span>,  <span class="hljs-comment">// request format: jsonp</span></span><br><span class="line">    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="hljs-string">'post'</span>,</span><br><span class="line">    url: <span class="hljs-string">'http://127.0.0.1:5000/demo/data'</span>,</span><br><span class="line">    data: <span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-string">'trans'</span>: trans, <span class="hljs-string">"core"</span>: core, <span class="hljs-string">"year"</span>: year, <span class="hljs-string">"month"</span>: month&#125;),</span><br><span class="line">    dataType: <span class="hljs-string">"jsonp"</span>,</span><br><span class="line">    contentType: <span class="hljs-string">"application/json; charset=utf-8"</span>,</span><br><span class="line">    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近整了点web相关的工作，借此整理了一下HTTP请求相关的内容。&lt;/p&gt;
&lt;h2 id=&quot;HTTP-Hyper-Text-Transfer-Protocol&quot;&gt;&lt;a href=&quot;#HTTP-Hyper-Text-Transfer-Protocol&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="web" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/web/"/>
    
    
      <category term="web" scheme="SJTUGavinLiu.github.io/tags/web/"/>
    
      <category term="AJAX" scheme="SJTUGavinLiu.github.io/tags/AJAX/"/>
    
      <category term="http" scheme="SJTUGavinLiu.github.io/tags/http/"/>
    
      <category term="get" scheme="SJTUGavinLiu.github.io/tags/get/"/>
    
      <category term="post" scheme="SJTUGavinLiu.github.io/tags/post/"/>
    
  </entry>
  
  <entry>
    <title>同时在Github与Coding上部署Hexo</title>
    <link href="SJTUGavinLiu.github.io/2020/01/18/%E5%90%8C%E6%97%B6%E5%9C%A8Github%E4%B8%8ECoding%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo/"/>
    <id>SJTUGavinLiu.github.io/2020/01/18/%E5%90%8C%E6%97%B6%E5%9C%A8Github%E4%B8%8ECoding%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo/</id>
    <published>2020-01-17T16:37:18.000Z</published>
    <updated>2020-01-17T16:38:03.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h2><p>我们可以通过SSH公钥来访问仓库，生成公钥的操作如下（配置的过程默认即可）</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &lt;your_email@example.com&gt;</span><br></pre></td></tr></table></figure><p>将生成的<code>id_rsa.pub</code>内容添加到Coding与Github的SSH公钥即可。</p><p>之后我们就可以直接对仓库进行操作，而不需要输入用户名和密码了，例如</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git@git.coding.net:Gavin_liudu/Gavin_liudu.coding.me.git</span><br><span class="line">git@github.com:SJTUGavinLiu/SJTUGavinLiu.github.io.git</span><br></pre></td></tr></table></figure><p>之后在blog根目录下的<code>_config.yml</code>中如下设置即可</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">deploy:</span></span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">git</span> </span><br><span class="line"><span class="hljs-attr">  repo:</span> </span><br><span class="line"><span class="hljs-attr">    github:</span> <span class="hljs-attr">https://github.com/SJTUGavinLiu/SJTUGavinLiu.github.io.git,master</span></span><br><span class="line"><span class="hljs-attr">    coding:</span> <span class="hljs-string">git@git.coding.net:Gavin_liudu/Gavin_liudu.coding.me.git,master</span></span><br></pre></td></tr></table></figure><h2 id="个人域名绑定"><a href="#个人域名绑定" class="headerlink" title="个人域名绑定"></a>个人域名绑定</h2><p>在阿里云的域名列表中加入记录</p><ol><li>主机记录www，记录类型A，记录值是IP地址，</li><li>设置主机记录@，记录类型CNAME，记录值是Page页面地址</li></ol><h2 id="文本内的图片插入"><a href="#文本内的图片插入" class="headerlink" title="文本内的图片插入"></a>文本内的图片插入</h2><p>一开始有考虑用图床来实现图片的中转，但是有两个问题还是让我放弃这一个想法</p><ol><li>图床存在挂掉的可能性（图床挂了，页面里的图片就全崩了，恢复极其麻烦）</li><li>由于我平时习惯用typora来写一些内容，所以图片都默认使用相对路径的形式在文本中进行标识。图床多出了上传图片并修改文本中图片地址的过程，实在麻烦</li></ol><p>因此我还是选择了把图片存在了<code>source/images/</code>的路径下，通过相对路径的形式调取。</p><h2 id="GIT-LFS的引入"><a href="#GIT-LFS的引入" class="headerlink" title="GIT LFS的引入"></a>GIT LFS的引入</h2><p>Git在存储二进制文件，例如音频，图像，视频等的时候效率不高，因为Git默认会压缩并存储二进制文件的所有完整版本。由于我选择将图片存入仓库中，随着博文数量的增加，Git仓库文件会不断地增长，最终超出容量的上界。</p><p>针对这个问题，Git-LFS提供了一个合理的解决方案，即只在真正的Git仓库中保存二进制文件的哈希等数据，而将真实的文件存储在GIT-LFS的服务器上。</p><p>Git LFS的处理方式类似于<code>.gitignore</code></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git lfs track <span class="hljs-string">"*.png"</span></span><br></pre></td></tr></table></figure><p>一切似乎都非常美好，然而悲伤的是，我的博客是基于Github/Coding Page的，所以图片必须上传到repo里，否则似乎无法显示QAQ，因此Git-LFS的方案只能暂时弃置。</p><h2 id="Typora与Hexo的对接"><a href="#Typora与Hexo的对接" class="headerlink" title="Typora与Hexo的对接"></a>Typora与Hexo的对接</h2><p>整了一个小脚本，可以把Typora中写好的东西打上分类，标签导入<code>_post</code>文件夹里（包括图片）详见<a href="https://github.com/SJTUGavinLiu/Tools" target="_blank" rel="noopener">Typora2hexo.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置SSH公钥&quot;&gt;&lt;a href=&quot;#配置SSH公钥&quot; class=&quot;headerlink&quot; title=&quot;配置SSH公钥&quot;&gt;&lt;/a&gt;配置SSH公钥&lt;/h2&gt;&lt;p&gt;我们可以通过SSH公钥来访问仓库，生成公钥的操作如下（配置的过程默认即可）&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
    
      <category term="文档" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
      <category term="博客搭建" scheme="SJTUGavinLiu.github.io/categories/%E6%96%87%E6%A1%A3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="SSH" scheme="SJTUGavinLiu.github.io/tags/SSH/"/>
    
      <category term="Git" scheme="SJTUGavinLiu.github.io/tags/Git/"/>
    
      <category term="域名" scheme="SJTUGavinLiu.github.io/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>博客开张</title>
    <link href="SJTUGavinLiu.github.io/2020/01/17/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0/"/>
    <id>SJTUGavinLiu.github.io/2020/01/17/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0/</id>
    <published>2020-01-16T17:44:24.000Z</published>
    <updated>2020-01-17T16:29:48.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「Gavin的碎碎念-」开张"><a href="#「Gavin的碎碎念-」开张" class="headerlink" title="「Gavin的碎碎念~」开张^^"></a>「Gavin的碎碎念~」开张^^</h1><h2 id="关于为什么开这个博客"><a href="#关于为什么开这个博客" class="headerlink" title="关于为什么开这个博客"></a>关于为什么开这个博客</h2><p>平时也会用Typora写一些东西，写的多了，查阅起来就不是很方便了。因此我就想到利用Hexo+Github Page建立一个静态博客，一方面省去了服务器的开支，另一方面可以利用现成的模板设计去实现类似于查找，归类，时间线的功能，省去了自己重复开发的时间。没有的功能自己魔改也并不麻烦。于是乎，「Gavin的碎碎念~」就诞生了：）</p><h2 id="博客里会有些啥嘞"><a href="#博客里会有些啥嘞" class="headerlink" title="博客里会有些啥嘞"></a>博客里会有些啥嘞</h2><p>所谓碎碎念，就是啥都会谈一些。内容不局限于以下</p><ol><li>技术文档（最近在刷leetcode可能也会写一些例题相关ORZ）</li><li>生活分享与一些小随笔</li><li>游戏的体验评测（八方旅人ing，或许也会有音乐，电影，书籍这些，<del>根本就很少看书了好伐</del>）</li><li>练琴（Guitar &amp; Keyboard）的心得体会以及一些基础乐理的笔记</li><li><del>flag</del></li></ol><h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>从「Gavin的碎碎念~」开始，养成做完事后复盘的好习惯，接受一切监督QAQ。绝不咕咕咕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;「Gavin的碎碎念-」开张&quot;&gt;&lt;a href=&quot;#「Gavin的碎碎念-」开张&quot; class=&quot;headerlink&quot; title=&quot;「Gavin的碎碎念~」开张^^&quot;&gt;&lt;/a&gt;「Gavin的碎碎念~」开张^^&lt;/h1&gt;&lt;h2 id=&quot;关于为什么开这个博客&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="随笔" scheme="SJTUGavinLiu.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
